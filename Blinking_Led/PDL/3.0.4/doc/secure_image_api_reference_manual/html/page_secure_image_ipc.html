<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cypress Secure Image: Inter-Processor Communication (IPC)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="cypress_logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Cypress Secure Image
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('page_secure_image_ipc.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Inter-Processor Communication (IPC) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The IPC_STRUCT, IPC_INTR_STRUCT and the data region referenced in IPC_STRUCT.DATA are intentionally left unprotected by the secure image as the protection scheme is entirely application specific.</p>
<p>These regions need to be accessible by bus masters with specific access settings and hence the strategy in protecting the IPC channel and ensuring data integrity need to be driven from the client software. As a guide, there are two general methods that can be used for ensuring secure access of these registers and memory regions.</p>
<h1><a class="anchor" id="group_secure_image_ipc1"></a>
IPC Protection Method 1</h1>
<p>The client application has a framework responsible for setting the PC of the non-secure bus master (e.g. CM4) to a PC!=0 value. For example, a system can be constructed using a combination of protection units and a mechanism to allow only privileged code to make changes to the PC value. Then the privileged code can protect the IPC_STRUCT, IPC_INTR_STRUCT and IPC data to allow only a certain PC value to access them (e.g. PC=2). Once this configuration is in place, IPC requests can only be made by bus masters that have the same access settings (e.g. PC=2, privileged). PC=0 bus masters (e.g. CM0+) have full access to all resources and can read/write to those IPC registers and memory regions. Once the channel is released, the chosen process (PC=2) on the user application can optionally disable the protection unit to allow access by other processes. The advantage of this method is that it is relatively simple and the user application has full control over the register and memory protection settings. The disadvantage is that if the PC switching is compromised in the software, or if another master can be configured to run at the chosen PC value for IPC access, then the security is compromised.</p>
<h1><a class="anchor" id="group_secure_image_ipc2"></a>
IPC Protection Method 2</h1>
<p>The client user application can enable protection units to protect the IPC_STRUCT, IPC_INTR_STRUCT and IPC_STRUCT.DATA regions at PC=0. This would effectively lock out any bus master from accessing (allow reads but disallow writes) the content. The only entity allowed to access it then would be the PC=0 task in the Secure image. The advantage of this method is that no bus master can access the registers and memory once the protection units are enabled. The disadvantage is that in the case of IPC_STRUCT and IPC_INTR_STRUCT registers, the protection units must be enabled after initiating the IPC request and would lead to coherency problems in a multi-bus master system. For example there is a chance that the IPC_STRUCT can be hijacked during the time between the IPC request and the protection unit enable. The protection unit must also be enabled in a critical section with the interrupts disabled. However, protecting the memory region accessed by IPC_STRUCT.DATA does not have this problem and may be a more robust method than option 1. The secure task can check whether the protection unit was enabled before executing the routine and then disable the protection unit after releasing the IPC. This way, the data integrity is guaranteed.</p>
<h1><a class="anchor" id="group_secure_image_ipc_guard"></a>
Additional Guard</h1>
<p>Protecting the integrity of the IPC is an important design consideration as it is a conduit for passing commands to the secure (PC=0) core. Another effort to ensure this is for secure tasks to be updated to provide non-repudiation by checking for the validity of the bus master access that acquired the IPC lock (cross-check that IPC_STRUCT.ACQUIRE is as expected) and that any protection units protecting the IPC data are properly configured and enabled.</p>
<p>In order to ensure that the client application is passing the acceptable parameters along with the issued commands, the contents of the IPC_STRUCT.DATA are examined and checked against a blacklist. This blacklist is used to confirm that memory addresses referenced in these parameters are not in the disallowed (secure) memory. E.g. a Crypto memory copy operation should not be able to move secure key in Flash to a RAM buffer. However this system relies on the validity of the IPC data and that it is unchanged during the secure task execution. Therefore the client software must protect it when issuing the command. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>Cypress Secure Image</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
