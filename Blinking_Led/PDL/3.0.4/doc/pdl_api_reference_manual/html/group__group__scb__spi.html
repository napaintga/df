<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cypress Peripheral Driver Library (PDL): SPI (SCB)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="cypress_logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Cypress Peripheral Driver Library (PDL)
   &#160;<span id="projectnumber">Version 3.0.4.57</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__scb__spi.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">API Reference</a>  </div>
  <div class="headertitle">
<div class="title">SPI (SCB)<div class="ingroups"><a class="el" href="group__group__scb.html">Serial Communication Block (SCB)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p>Driver API for SPI Bus Peripheral. </p>
<p>Three different SPI protocols or modes are supported:</p><ul>
<li>The original SPI protocol as defined by Motorola.</li>
<li>TI: Uses a short pulse on "spi_select" to indicate a start of transaction.</li>
<li>National Semiconductor (Microwire): Transmissions and Receptions occur separately. In addition to the standard 8-bit word length, the component supports a configurable 4- to 16-bit data width for communicating at non-standard SPI data widths.</li>
</ul>
<h1><a class="anchor" id="group_scb_spi_configuration"></a>
Configuration Considerations</h1>
<p>The SPI driver configuration can be divided to number of sequential steps listed below:</p><ul>
<li><a class="el" href="group__group__scb__spi.html#group_scb_spi_config">Configure SPI</a></li>
<li><a class="el" href="group__group__scb__spi.html#group_scb_spi_pins">Assign and Configure Pins</a></li>
<li><a class="el" href="group__group__scb__spi.html#group_scb_spi_clock">Assign Clock Divider</a></li>
<li><a class="el" href="group__group__scb__spi.html#group_scb_spi_data_rate">Configure Data Rate</a></li>
<li><a class="el" href="group__group__scb__spi.html#group_scb_spi_intr">Configure Interrupt</a></li>
<li><a class="el" href="group__group__scb__spi.html#group_scb_spi_enable">Enable SPI</a></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The SPI driver is built on top of the SCB hardware block. The SCB1 instance is used as an example for all code snippets. Modify the code to match your design.</dd></dl>
<h2><a class="anchor" id="group_scb_spi_config"></a>
Configure SPI</h2>
<p>To set up the SPI slave driver, provide the configuration parameters in the <a class="el" href="structcy__stc__scb__spi__config__t.html">cy_stc_scb_spi_config_t</a> structure. For example: provide spiMode, subMode, sclkMode, oversample, rxDataWidth, and txDataWidth. The other parameters are optional for operation. To initialize the driver, call <a class="el" href="group__group__scb__spi__general__functions.html#gabe68169c810119b93e1164127663033c">Cy_SCB_SPI_Init</a> function providing a pointer to the filled <a class="el" href="structcy__stc__scb__spi__config__t.html">cy_stc_scb_spi_config_t</a> structure and allocated <a class="el" href="structcy__stc__scb__spi__context__t.html">cy_stc_scb_spi_context_t</a>.</p>
<div class="fragment"><div class="line"><span class="comment">/* Allocate context for SPI operation */</span></div><div class="line"><a class="code" href="structcy__stc__scb__spi__context__t.html">cy_stc_scb_spi_context_t</a> spiContext;</div><div class="line"></div><div class="line"><span class="comment">/* Populate configuration structure */</span></div><div class="line"><span class="preprocessor">#if (USE_SPI_SLAVE)</span></div><div class="line">    <span class="comment">/* Slave configuration */</span></div><div class="line">    <a class="code" href="structcy__stc__scb__spi__config__t.html">cy_stc_scb_spi_config_t</a> spiConfig =</div><div class="line">    {</div><div class="line">        .<a class="code" href="structcy__stc__scb__spi__config__t.html#a4fc24e3daa02dc8a81de14341a954110">spiMode</a>  = <a class="code" href="group__group__scb__spi__enums.html#gga931ca8a003e3da524aadd562945d3ab5a6b016365095f773e900be90867db0976">CY_SCB_SPI_SLAVE</a>,</div><div class="line">        .subMode  = <a class="code" href="group__group__scb__spi__enums.html#gga1410916a9c76b0d86eb196b8e9ed547fa62fab87ba422296db9c490c3b74830ab">CY_SCB_SPI_MOTOROLA</a>,</div><div class="line">        .sclkMode = <a class="code" href="group__group__scb__spi__enums.html#ggab34eae51343cebfec7c447a573cdf0baac7839625f0402b7b9685f3fc2c8a2305">CY_SCB_SPI_CPHA0_CPOL0</a>,</div><div class="line">        .oversample = 0UL, <span class="comment">/* Does not care for a slave */</span></div><div class="line"></div><div class="line">        .rxDataWidth              = 8UL,</div><div class="line">        .txDataWidth              = 8UL,</div><div class="line">        .enableMsbFirst           = <span class="keyword">false</span>,</div><div class="line">        .enableInputFilter        = <span class="keyword">false</span>,</div><div class="line">        .enableFreeRunSclk        = <span class="keyword">false</span>,</div><div class="line">        .enableMisoLateSample     = <span class="keyword">false</span>,</div><div class="line">        .enableTransferSeperation = <span class="keyword">false</span>,</div><div class="line">        .ssPolarity               = <a class="code" href="group__group__scb__spi__enums.html#ggac1d52a37938101b62b908fb4263d98a2ab36d0ae32e47bb37ec614d9bc58b7198">CY_SCB_SPI_ACTIVE_LOW</a>,</div><div class="line">        .enableWakeFromSleep      = <span class="keyword">false</span>,</div><div class="line"></div><div class="line">        .rxFifoTriggerLevel  = 0UL,</div><div class="line">        .rxFifoIntEnableMask = 0UL,</div><div class="line">        .txFifoTriggerLevel  = 0UL,</div><div class="line">        .txFifoIntEnableMask = 0UL,</div><div class="line">        .masterSlaveIntEnableMask = 0UL,</div><div class="line">    };</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    <span class="comment">/* Master configuration */</span></div><div class="line">    <a class="code" href="structcy__stc__scb__spi__config__t.html">cy_stc_scb_spi_config_t</a> spiConfig =</div><div class="line">    {</div><div class="line">        .<a class="code" href="structcy__stc__scb__spi__config__t.html#a4fc24e3daa02dc8a81de14341a954110">spiMode</a>  = <a class="code" href="group__group__scb__spi__enums.html#gga931ca8a003e3da524aadd562945d3ab5aac0d1cba1a96754415d7457a35cf6510">CY_SCB_SPI_MASTER</a>,</div><div class="line">        .subMode  = <a class="code" href="group__group__scb__spi__enums.html#gga1410916a9c76b0d86eb196b8e9ed547fa62fab87ba422296db9c490c3b74830ab">CY_SCB_SPI_MOTOROLA</a>,</div><div class="line">        .sclkMode = <a class="code" href="group__group__scb__spi__enums.html#ggab34eae51343cebfec7c447a573cdf0baac7839625f0402b7b9685f3fc2c8a2305">CY_SCB_SPI_CPHA0_CPOL0</a>,</div><div class="line">        .oversample = 10UL,</div><div class="line"></div><div class="line">        .rxDataWidth              = 8UL,</div><div class="line">        .txDataWidth              = 8UL,</div><div class="line">        .enableMsbFirst           = <span class="keyword">false</span>,</div><div class="line">        .enableInputFilter        = <span class="keyword">false</span>,</div><div class="line">        .enableFreeRunSclk        = <span class="keyword">false</span>,</div><div class="line">        .enableMisoLateSample     = <span class="keyword">true</span>,</div><div class="line">        .enableTransferSeperation = <span class="keyword">false</span>,</div><div class="line">        .ssPolarity               = <a class="code" href="group__group__scb__spi__enums.html#ggac1d52a37938101b62b908fb4263d98a2ab36d0ae32e47bb37ec614d9bc58b7198">CY_SCB_SPI_ACTIVE_LOW</a>,</div><div class="line">        .enableWakeFromSleep      = <span class="keyword">false</span>,</div><div class="line"></div><div class="line">        .rxFifoTriggerLevel  = 0UL,</div><div class="line">        .rxFifoIntEnableMask = 0UL,</div><div class="line">        .txFifoTriggerLevel  = 0UL,</div><div class="line">        .txFifoIntEnableMask = 0UL,</div><div class="line">        .masterSlaveIntEnableMask = 0UL,</div><div class="line">    };</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="comment">/* Configure SPI to operate */</span></div><div class="line">(void) <a class="code" href="group__group__scb__spi__general__functions.html#gabe68169c810119b93e1164127663033c">Cy_SCB_SPI_Init</a>(SCB1, &amp;spiConfig, &amp;spiContext);</div></div><!-- fragment --> <h2><a class="anchor" id="group_scb_spi_pins"></a>
Assign and Configure Pins</h2>
<p>Only dedicated SCB pins can be used for SPI operation. The HSIOM register must be configured to connect block to the pins. Also the SPI output pins must be configured in Strong Drive mode and SPI input pins in Digital High-Z:</p>
<div class="fragment"><div class="line"><span class="comment">/* Assign pins for SPI on SCB1: P10[0], P10[1], P10[2] and P10[3] */</span></div><div class="line"><span class="preprocessor">#define SPI_PORT        P10_0_PORT</span></div><div class="line"><span class="preprocessor">#define SPI_MISO_NUM    P10_0_NUM</span></div><div class="line"><span class="preprocessor">#define SPI_MOSI_NUM    P10_1_NUM</span></div><div class="line"><span class="preprocessor">#define SPI_SCLK_NUM    P10_2_NUM</span></div><div class="line"><span class="preprocessor">#define SPI_SS_NUM      P10_3_NUM</span></div><div class="line"></div><div class="line"><span class="comment">/* Connect SCB1 SPI function to pins */</span></div><div class="line"><a class="code" href="group__group__gpio__functions__init.html#ga83a06264feed0e1042671a74339ea155">Cy_GPIO_SetHSIOM</a>(SPI_PORT, SPI_MISO_NUM, P10_1_SCB1_SPI_MISO);</div><div class="line"><a class="code" href="group__group__gpio__functions__init.html#ga83a06264feed0e1042671a74339ea155">Cy_GPIO_SetHSIOM</a>(SPI_PORT, SPI_MOSI_NUM, P10_0_SCB1_SPI_MOSI);</div><div class="line"><a class="code" href="group__group__gpio__functions__init.html#ga83a06264feed0e1042671a74339ea155">Cy_GPIO_SetHSIOM</a>(SPI_PORT, SPI_SCLK_NUM, P10_2_SCB1_SPI_CLK);</div><div class="line"><a class="code" href="group__group__gpio__functions__init.html#ga83a06264feed0e1042671a74339ea155">Cy_GPIO_SetHSIOM</a>(SPI_PORT, SPI_SS_NUM,   P10_3_SCB1_SPI_SELECT0);</div><div class="line"></div><div class="line"><span class="preprocessor">#if (USE_SPI_SLAVE)</span></div><div class="line">    <span class="comment">/* Configure SCB1 pins for SPI Slave operation */</span></div><div class="line">    <a class="code" href="group__group__gpio__functions__gpio.html#ga97e64dc8c45e7cd73e3012100d03b1fd">Cy_GPIO_SetDrivemode</a>(SPI_PORT, SPI_MISO_NUM, <a class="code" href="group__group__gpio__drive_modes.html#gacebd8bea6222d742bdfbfd86dabab940">CY_GPIO_DM_STRONG_IN_OFF</a>);</div><div class="line">    <a class="code" href="group__group__gpio__functions__gpio.html#ga97e64dc8c45e7cd73e3012100d03b1fd">Cy_GPIO_SetDrivemode</a>(SPI_PORT, SPI_MOSI_NUM, <a class="code" href="group__group__gpio__drive_modes.html#gaf2fe5dc00ba1770b37e620a01169485c">CY_GPIO_DM_HIGHZ</a>);</div><div class="line">    <a class="code" href="group__group__gpio__functions__gpio.html#ga97e64dc8c45e7cd73e3012100d03b1fd">Cy_GPIO_SetDrivemode</a>(SPI_PORT, SPI_SCLK_NUM, <a class="code" href="group__group__gpio__drive_modes.html#gaf2fe5dc00ba1770b37e620a01169485c">CY_GPIO_DM_HIGHZ</a>);</div><div class="line">    <a class="code" href="group__group__gpio__functions__gpio.html#ga97e64dc8c45e7cd73e3012100d03b1fd">Cy_GPIO_SetDrivemode</a>(SPI_PORT, SPI_SS_NUM,   <a class="code" href="group__group__gpio__drive_modes.html#gaf2fe5dc00ba1770b37e620a01169485c">CY_GPIO_DM_HIGHZ</a>);</div><div class="line"><span class="preprocessor">#else </span><span class="comment">/* (USE_SPI_SLAVE) */</span><span class="preprocessor"></span></div><div class="line">    <span class="comment">/* Configure SCB1 pins for SPI Master operation */</span></div><div class="line">    <a class="code" href="group__group__gpio__functions__gpio.html#ga97e64dc8c45e7cd73e3012100d03b1fd">Cy_GPIO_SetDrivemode</a>(SPI_PORT, SPI_MISO_NUM, <a class="code" href="group__group__gpio__drive_modes.html#gaf2fe5dc00ba1770b37e620a01169485c">CY_GPIO_DM_HIGHZ</a>);</div><div class="line">    <a class="code" href="group__group__gpio__functions__gpio.html#ga97e64dc8c45e7cd73e3012100d03b1fd">Cy_GPIO_SetDrivemode</a>(SPI_PORT, SPI_MOSI_NUM, <a class="code" href="group__group__gpio__drive_modes.html#gacebd8bea6222d742bdfbfd86dabab940">CY_GPIO_DM_STRONG_IN_OFF</a>);</div><div class="line">    <a class="code" href="group__group__gpio__functions__gpio.html#ga97e64dc8c45e7cd73e3012100d03b1fd">Cy_GPIO_SetDrivemode</a>(SPI_PORT, SPI_SCLK_NUM, <a class="code" href="group__group__gpio__drive_modes.html#gacebd8bea6222d742bdfbfd86dabab940">CY_GPIO_DM_STRONG_IN_OFF</a>);</div><div class="line">    <a class="code" href="group__group__gpio__functions__gpio.html#ga97e64dc8c45e7cd73e3012100d03b1fd">Cy_GPIO_SetDrivemode</a>(SPI_PORT, SPI_SS_NUM,   <a class="code" href="group__group__gpio__drive_modes.html#gacebd8bea6222d742bdfbfd86dabab940">CY_GPIO_DM_STRONG_IN_OFF</a>);</div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>The SCB stops driving pins when it is disabled or enters low power mode (except Alternate Active or Sleep). To keep the pins' states, they should be reconfigured or be frozen.</dd></dl>
<h2><a class="anchor" id="group_scb_spi_clock"></a>
Assign Clock Divider</h2>
<p>The clock source must be connected to the SCB block to oversample input and output signals. You must use one of the 8-bit or 16-bit dividers <em><b>(the source clock of this divider must be Clk_Peri)</b></em>. Use the <a class="el" href="group__group__sysclk.html">System Clock (SysClk)</a> driver API to do that.</p>
<div class="fragment"><div class="line"><span class="comment">/* Assign divider type and number for SPI */</span></div><div class="line"><span class="preprocessor">#define SPI_CLK_DIV_TYPE    (CY_SYSCLK_DIV_8_BIT)</span></div><div class="line"><span class="preprocessor">#define SPI_CLK_DIV_NUM     (0U)</span></div><div class="line"></div><div class="line"><span class="comment">/* Connect assigned divider to be a clock source for SPI */</span></div><div class="line"><a class="code" href="group__group__sysclk__clk__peripheral__funcs.html#gacb66324e3191006f6d1cee8b29238fb2">Cy_SysClk_PeriphAssignDivider</a>(PCLK_SCB1_CLOCK, SPI_CLK_DIV_TYPE, SPI_CLK_DIV_NUM);</div></div><!-- fragment --> <h2><a class="anchor" id="group_scb_spi_data_rate"></a>
Configure Data Rate</h2>
<p>To get the SPI slave to operate with the desired data rate, the source clock must be fast enough to provide sufficient oversampling. Therefore, the clock divider must be configured to provide desired clock frequency. Use the <a class="el" href="group__group__sysclk.html">System Clock (SysClk)</a> driver API to do that.</p>
<div class="fragment"><div class="line"><span class="comment">/* SPI data rate is defined by the SPI master because it drives SCLK.</span></div><div class="line"><span class="comment">* Configure SPI slave source clock to be PeriClk. This configuration</span></div><div class="line"><span class="comment">* enables SPI slave operate up to maximum supported data rate.</span></div><div class="line"><span class="comment">* For PeriClk = 50 MHz, select divider value 1 and get SCB clock = (50 MHz / 1) = 50 MHz.</span></div><div class="line"><span class="comment">* Adjust SPI slave clock source frequency after defining how much SPI slave</span></div><div class="line"><span class="comment">* has to oversample desired data rate.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><a class="code" href="group__group__sysclk__clk__peripheral__funcs.html#gac67931844e6ec06b5ff88f4f3119e127">Cy_SysClk_PeriphSetDivider</a>   (SPI_CLK_DIV_TYPE, SPI_CLK_DIV_NUMBER, 0UL);</div><div class="line"><a class="code" href="group__group__sysclk__clk__peripheral__funcs.html#ga8c626f11b583d8296516bbcf4a22f98e">Cy_SysClk_PeriphEnableDivider</a>(SPI_CLK_DIV_TYPE, SPI_CLK_DIV_NUMBER);</div></div><!-- fragment --><p> To get the SPI master to operate with the desired data rate, the source clock frequency and the SCLK (SPI clock) period must be configured. Use the <a class="el" href="group__group__sysclk.html">System Clock (SysClk)</a> driver API to configure source clock frequency. Set the <em><b>oversample parameter in configuration structure</b></em> to define number of SCB clocks in one SCLK period. When this value is even, the first and second phases of the SCLK period are the same. Otherwise, the first phase is one SCB clock cycle longer than the second phase. The level of the first phase of the clock period depends on CPOL settings: 0 - low level and 1 - high level.</p>
<div class="fragment"><div class="line"><span class="comment">/* SPI master desired data rate is 1 Mbps.</span></div><div class="line"><span class="comment">* The SPI master data rate = (SCB clock frequency / Oversample).</span></div><div class="line"><span class="comment">* For PeriClk = 50 MHz, select divider value 5 and get SCB clock = (50 MHz / 5) = 10 MHz.</span></div><div class="line"><span class="comment">* Select Oversample = 10. These setting results SPI data rate = 10 MHz / 10 = 1 Mbps.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><a class="code" href="group__group__sysclk__clk__peripheral__funcs.html#gac67931844e6ec06b5ff88f4f3119e127">Cy_SysClk_PeriphSetDivider</a>   (SPI_CLK_DIV_TYPE, SPI_CLK_DIV_NUMBER, 4UL);</div><div class="line"><a class="code" href="group__group__sysclk__clk__peripheral__funcs.html#ga8c626f11b583d8296516bbcf4a22f98e">Cy_SysClk_PeriphEnableDivider</a>(SPI_CLK_DIV_TYPE, SPI_CLK_DIV_NUMBER);</div></div><!-- fragment --><p> Refer to the technical reference manual (TRM) section SPI sub-section Oversampling and Bit Rate to get information about how to configure SPI to run with desired data rate.</p>
<h2><a class="anchor" id="group_scb_spi_intr"></a>
Configure Interrupt</h2>
<p>The interrupt is optional for the SPI operation. To configure the interrupt, the <a class="el" href="group__group__scb__spi__interrupt__functions.html#ga0adeb497479d79c9ecea8169cfaff114">Cy_SCB_SPI_Interrupt</a> function must be called in the interrupt handler for the selected SCB instance. Also, this interrupt must be enabled in the NVIC.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> SPI_Isr(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group__group__scb__spi__interrupt__functions.html#ga0adeb497479d79c9ecea8169cfaff114">Cy_SCB_SPI_Interrupt</a>(SCB1, &amp;spiContext);</div><div class="line">}</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">/* Assign SPI interrupt number and priority */</span></div><div class="line"><span class="preprocessor">#define SPI_INTR_NUM        ((IRQn_Type) scb_1_interrupt_IRQn)</span></div><div class="line"><span class="preprocessor">#define SPI_INTR_PRIORITY   (7U)</span></div><div class="line"></div><div class="line"><span class="comment">/* Populate configuration structure (code specific for CM4) */</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="structcy__stc__sysint__t.html">cy_stc_sysint_t</a> spiIntrConfig =</div><div class="line">{</div><div class="line">    .<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>      = SPI_INTR_NUM,</div><div class="line">    .intrPriority = SPI_INTR_PRIORITY,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* Hook interrupt service routine and enable interrupt */</span></div><div class="line">(void) <a class="code" href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d">Cy_SysInt_Init</a>(&amp;spiIntrConfig, &amp;SPI_Isr);</div><div class="line">NVIC_EnableIRQ(SPI_INTR_NUM);</div></div><!-- fragment --> <h2><a class="anchor" id="group_scb_spi_enable"></a>
Enable SPI</h2>
<p>Finally, enable the SPI operation calling <a class="el" href="group__group__scb__spi__general__functions.html#ga7e5d7cb17044cdd8ab1543e038bf89a8">Cy_SCB_SPI_Enable</a>. For the slave, this means that SPI device starts respond to the transfers. For the master, it is ready to execute transfers.</p>
<div class="fragment"><div class="line"><span class="comment">/* Enable SPI to operate */</span></div><div class="line"><a class="code" href="group__group__scb__spi__general__functions.html#ga7e5d7cb17044cdd8ab1543e038bf89a8">Cy_SCB_SPI_Enable</a>(SCB1);</div><div class="line"></div><div class="line"><span class="comment">/* Enable global interrupts */</span></div><div class="line">__enable_irq();</div></div><!-- fragment --> <h1><a class="anchor" id="group_scb_spi_use_cases"></a>
Common Use Cases</h1>
<p>The SPI API is the same for the master and slave mode operation and is divided into two categories: <a class="el" href="group__group__scb__spi__low__level__functions.html">Low-Level</a> and <a class="el" href="group__group__scb__spi__high__level__functions.html">High-Level</a>. <br />
<em>Do not mix <b>High-Level</b> and <b>Low-Level</b> API because a Low-Level API can adversely affect the operation of a High-Level API.</em></p>
<h2><a class="anchor" id="group_scb_spi_ll"></a>
Low-Level API</h2>
<p>The <a class="el" href="group__group__scb__spi__low__level__functions.html">Low-Level</a> API allows interacting directly with the hardware and do not use interrupt. These functions do not require context for operation. Thus, NULL can be passed in <a class="el" href="group__group__scb__spi__general__functions.html#gabe68169c810119b93e1164127663033c">Cy_SCB_SPI_Init</a> and <a class="el" href="group__group__scb__spi__general__functions.html#ga01fcd87713fe370d94828563ff1e86b8">Cy_SCB_SPI_Disable</a> instead of a pointer to the context structure.</p>
<ul>
<li>To write data into the TX FIFO, use one of the provided functions: <a class="el" href="group__group__scb__spi__low__level__functions.html#ga6b613c5544c0595763e30d83da125a4d">Cy_SCB_SPI_Write</a>, <a class="el" href="group__group__scb__spi__low__level__functions.html#gad5415bd46d159b57f08fa0eb375a133e">Cy_SCB_SPI_WriteArray</a> or <a class="el" href="group__group__scb__spi__low__level__functions.html#ga6899c2b1dd9f868a7fb625b03a7ee594">Cy_SCB_SPI_WriteArrayBlocking</a>. Note that in the master mode, putting data into the TX FIFO starts a transfer. Due to the SPI nature, the received data is put into the RX FIFO.</li>
<li>To read data from the RX FIFO, use one of the provided functions: <a class="el" href="group__group__scb__spi__low__level__functions.html#ga169c313a3508261fa76e6b6600cce726">Cy_SCB_SPI_Read</a> or <a class="el" href="group__group__scb__spi__low__level__functions.html#gaecc7c7a8d0ba840fa5d65e5076cb9d84">Cy_SCB_SPI_ReadArray</a>.</li>
<li>The statuses can be polled using: <a class="el" href="group__group__scb__spi__low__level__functions.html#ga50acb3879906a729e5821fcc87d4f017">Cy_SCB_SPI_GetRxFifoStatus</a>, <a class="el" href="group__group__scb__spi__low__level__functions.html#ga987fdbe86c1fbfbadfa51cdf82f84632">Cy_SCB_SPI_GetTxFifoStatus</a> and <a class="el" href="group__group__scb__spi__low__level__functions.html#gac9e9a4b77a8db35ccbda974e7f9d9d23">Cy_SCB_SPI_GetSlaveMasterStatus</a>. <em>The statuses are <b>W1C (Write 1 to Clear)</b> and after a status is set, it must be cleared.</em> Note that there are statuses evaluated as level. These statuses remain set until an event is true. Therefore, after the clear operation, the status is cleared but then it is restored (if the event is still true). For example: the TX FIFO empty interrupt source can be cleared when the TX FIFO is not empty. Put at least two data elements (one goes to the shifter and next to FIFO) before clearing this status. <br />
 Also, following functions can be used for polling as well <a class="el" href="group__group__scb__spi__general__functions.html#ga4241f6166816159f7365220834a5e0d0">Cy_SCB_SPI_IsBusBusy</a>, <a class="el" href="group__group__scb__spi__low__level__functions.html#ga399842a2931b7c6cd85446a72cc2f81b">Cy_SCB_SPI_IsTxComplete</a>, <a class="el" href="group__group__scb__spi__low__level__functions.html#gaea6c37058e015b59c0e307d0d0e77ad0">Cy_SCB_SPI_GetNumInRxFifo</a> and <a class="el" href="group__group__scb__spi__low__level__functions.html#gad9be16f0ae646a85e9fffe9731cb4896">Cy_SCB_SPI_GetNumInTxFifo</a>.</li>
</ul>
<div class="fragment"><div class="line">uint8_t txBuffer[BUFFER_SIZE];</div><div class="line"></div><div class="line"><span class="comment">/* Initialize txBuffer with command to transfer */</span></div><div class="line">memcpy(txBuffer, dataToTransfer, <span class="keyword">sizeof</span>(txBuffer));</div><div class="line"></div><div class="line"><span class="comment">/* Master: start a transfer. Slave: prepare for a transfer. */</span></div><div class="line"><a class="code" href="group__group__scb__spi__low__level__functions.html#ga6899c2b1dd9f868a7fb625b03a7ee594">Cy_SCB_SPI_WriteArrayBlocking</a>(SCB1, txBuffer, <span class="keyword">sizeof</span>(txBuffer));</div><div class="line"></div><div class="line"><span class="comment">/* Blocking wait for transfer completion */</span></div><div class="line"><span class="keywordflow">while</span> (!<a class="code" href="group__group__scb__spi__low__level__functions.html#ga399842a2931b7c6cd85446a72cc2f81b">Cy_SCB_SPI_IsTxComplete</a>(SCB1))</div><div class="line">{</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Handle results of a transfer */</span></div></div><!-- fragment --> <h2><a class="anchor" id="group_scb_spi_hl"></a>
High-Level API</h2>
<p>The <a class="el" href="group__group__scb__spi__high__level__functions.html">High-Level</a> API uses an interrupt to execute a transfer. Call <a class="el" href="group__group__scb__spi__high__level__functions.html#ga6fdbb98ef7faddc5025fab510fb1617e">Cy_SCB_SPI_Transfer</a> to start communication: for the master mode, a transfer to the slave starts but for the slave mode, the Read and Write buffers are prepared for the following communication with the master. After a transfer is started, the <a class="el" href="group__group__scb__spi__interrupt__functions.html#ga0adeb497479d79c9ecea8169cfaff114">Cy_SCB_SPI_Interrupt</a> handles the transfer until its completion. Therefore, it must be called inside the user interrupt handler to make the High-Level API work. To monitor the status of the transfer operation, use <a class="el" href="group__group__scb__spi__high__level__functions.html#ga95069817e25be749ae989e5d7131f8d0">Cy_SCB_SPI_GetTransferStatus</a>. Alternatively, use <a class="el" href="group__group__scb__spi__interrupt__functions.html#ga5594391e0d6a0b020355761826de2e78">Cy_SCB_SPI_RegisterCallback</a> to register a callback function to be notified about <a class="el" href="group__group__scb__spi__macros__callback__events.html">SPI Callback Events</a>.</p>
<div class="fragment"><div class="line">uint8_t rxBuffer[BUFFER_SIZE];</div><div class="line">uint8_t txBuffer[BUFFER_SIZE];</div><div class="line"></div><div class="line"><span class="comment">/* Initialize txBuffer with command to transfer */</span></div><div class="line">memcpy(txBuffer, dataToTransfer, <span class="keyword">sizeof</span>(txBuffer));</div><div class="line"></div><div class="line"><span class="comment">/* Master: start a transfer. Slave: prepare for a transfer. */</span></div><div class="line">(void) <a class="code" href="group__group__scb__spi__high__level__functions.html#ga6fdbb98ef7faddc5025fab510fb1617e">Cy_SCB_SPI_Transfer</a>(SCB1, txBuffer, rxBuffer, <span class="keyword">sizeof</span>(txBuffer), &amp;spiContext);</div><div class="line"></div><div class="line"><span class="comment">/* Blocking wait for transfer completion */</span></div><div class="line"><span class="keywordflow">while</span> (0UL != (<a class="code" href="group__group__scb__spi__macros__xfer__status.html#gab024f7d6ed7cbaa36c80c904a6179de7">CY_SCB_SPI_TRANSFER_ACTIVE</a> &amp; <a class="code" href="group__group__scb__spi__high__level__functions.html#ga95069817e25be749ae989e5d7131f8d0">Cy_SCB_SPI_GetTransferStatus</a>(SCB1, &amp;spiContext)))</div><div class="line">{</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Handle results of a transfer */</span></div></div><!-- fragment --> <h1><a class="anchor" id="group_scb_spi_dma_trig"></a>
DMA Trigger</h1>
<p>The SCB provides TX and RX output trigger signals that can be routed to the DMA controller inputs. These signals are assigned based on the data availability in the TX and RX FIFOs appropriately.</p>
<ul>
<li>The RX trigger signal remains active until the number of data elements in the RX FIFO is greater than the value of RX FIFO level. Use function <a class="el" href="group__group__scb__common__functions.html#ga64d034531ea5eb2695ed018d6a75da68">Cy_SCB_SetRxFifoLevel</a> or set configuration structure rxFifoTriggerLevel parameter to configure RX FIFO level value. <br />
 <em>For example, the RX FIFO has 8 data elements and the RX FIFO level is 0. The RX trigger signal remains active until DMA does not read all data from the RX FIFO.</em></li>
<li>The TX trigger signal remains active until the number of data elements in the TX FIFO is less than the value of TX FIFO level. Use function <a class="el" href="group__group__scb__common__functions.html#ga36285e337c94df91a4ebe5b1ee0fd43d">Cy_SCB_SetTxFifoLevel</a> or set configuration structure txFifoTriggerLevel parameter to configure TX FIFO level value. <br />
 <em>For example, the TX FIFO has 0 data elements (empty) and the TX FIFO level is 7. The TX trigger signal remains active until DMA does not load TX FIFO with 7 data elements (note that after the first TX load operation, the data element goes to the shift register and TX FIFO remains empty).</em></li>
</ul>
<p>To route SCB TX or RX trigger signals to the DMA controller, use <a class="el" href="group__group__trigmux.html">Trigger multiplexer (TrigMux)</a> driver API.</p>
<dl class="section note"><dt>Note</dt><dd>To properly handle DMA level request signal activation and de-activation from the SCB peripheral block the DMA Descriptor typically must be configured to re-trigger after 16 Clk_Slow cycles.</dd></dl>
<h1><a class="anchor" id="group_scb_spi_lp"></a>
Low Power Support</h1>
<p>The SPI driver provides the callback functions to handle power mode transition. The callback <a class="el" href="group__group__scb__spi__low__power__functions.html#ga1410a154caf8e6389d00b35e3670e037">Cy_SCB_SPI_DeepSleepCallback</a> must be called during execution of <a class="el" href="group__group__syspm__functions__power.html#ga1211c6447be4863cb7ca807e2c9f98ee">Cy_SysPm_DeepSleep</a>; <a class="el" href="group__group__scb__spi__low__power__functions.html#gabffef0d78e2e6e17642ac5d721e4f60d">Cy_SCB_SPI_HibernateCallback</a> must be called during execution of <a class="el" href="group__group__syspm__functions__power.html#ga2929e98b966d58c9246108a767ed7f53">Cy_SysPm_Hibernate</a>. To trigger the callback execution, the callback must be registered before calling the power mode transition function. Refer to <a class="el" href="group__group__syspm.html">System Power Management (SysPm)</a> driver for more information about power mode transitions and callback registration.</p>
<p>The SPI master is disabled during Deep Sleep and Hibernate and stops driving the output pins. The state of the SPI master output pins SCLK, SS, and MOSI is High-Z, which can cause unexpected behavior of the SPI Slave due to possible glitches on these lines. These pins must be set to the inactive state before entering Deep Sleep or Hibernate mode. To do that, configure the SPI master pins output to drive the inactive state and High-Speed Input Output Multiplexer (HSIOM) to control output by GPIO (use <a class="el" href="group__group__gpio.html">General Purpose Input Output (GPIO)</a> driver API). The pins configuration must be restored after exiting Deep Sleep mode to return the SPI master control of the pins (after exiting Hibernate mode, the system init code does the same). Note that the SPI master must be enabled to drive the pins during configuration change not to cause glitches on the lines. Copy either or both <a class="el" href="group__group__scb__spi__low__power__functions.html#ga1410a154caf8e6389d00b35e3670e037">Cy_SCB_SPI_DeepSleepCallback</a> and <a class="el" href="group__group__scb__spi__low__power__functions.html#gabffef0d78e2e6e17642ac5d721e4f60d">Cy_SCB_SPI_HibernateCallback</a> as appropriate, and make the changes described above inside the function. Alternately, external pull-up or pull-down resistors can be connected to the appropriate SPI lines to keep them inactive during Deep-Sleep or Hibernate.</p>
<dl class="section note"><dt>Note</dt><dd>Only applicable for <b>rev-08 of the CY8CKIT-062-BLE</b>. For proper operation, when the SPI slave is configured to be a wakeup source from Deep Sleep mode, the <a class="el" href="group__group__scb__spi__low__power__functions.html#ga1410a154caf8e6389d00b35e3670e037">Cy_SCB_SPI_DeepSleepCallback</a> must be copied and modified. Refer to the function description to get the details.</dd></dl>
<h1><a class="anchor" id="group_scb_spi_more_information"></a>
More Information</h1>
<p>For more information on the SCB peripheral, refer to the technical reference manual (TRM).</p>
<h1><a class="anchor" id="group_scb_spi_MISRA"></a>
MISRA-C Compliance</h1>
<table class="doxtable">
<tr>
<th>MISRA Rule </th><th>Rule Class (Required/Advisory) </th><th>Rule Description </th><th>Description of Deviation(s)  </th></tr>
<tr>
<td>11.4 </td><td>A </td><td>A cast should not be performed between a pointer to object type and a different pointer to object type. </td><td><ul>
<li>The pointer to the buffer memory is void to allow handling different data types: uint8_t (4-8 bits) or uint16_t (9-16 bits). The cast operation is safe because the configuration is verified before operation is performed.</li>
<li>The functions <a class="el" href="group__group__scb__spi__low__power__functions.html#ga1410a154caf8e6389d00b35e3670e037">Cy_SCB_SPI_DeepSleepCallback</a> and <a class="el" href="group__group__scb__spi__low__power__functions.html#gabffef0d78e2e6e17642ac5d721e4f60d">Cy_SCB_SPI_HibernateCallback</a> are callback of <a class="el" href="group__group__syspm__data__enumerates.html#ga601b1cb722cb091133caf33d8ab235ca">cy_en_syspm_status_t</a> type. The cast operation safety in these functions becomes the user's responsibility because pointers are initialized when callback is registered in SysPm driver.  </li>
</ul>
</td></tr>
<tr>
<td>13.7 </td><td>R </td><td>Boolean operations whose results are invariant shall not be permitted. </td><td>The SCB block parameters can be a constant false or true depends on the selected device and cause this violation.  </td></tr>
<tr>
<td>14.1 </td><td>R </td><td>There shall be no unreachable code. </td><td>The SCB block parameters can be a constant false or true depends on the selected device and cause code to be unreachable.  </td></tr>
<tr>
<td>14.2 </td><td>R </td><td>All non-null statements shall either: a) have at least one side-effect however executed, or b) cause control flow to change. </td><td>The unused function parameters are cast to void. This statement has no side-effect and is used to suppress a compiler warning.  </td></tr>
<tr>
<td>14.7 </td><td>R </td><td>A function shall have a single point of exit at the end of the function. </td><td>The functions can return from several points. This is done to improve code clarity when returning error status code if input parameters validation is failed.  </td></tr>
</table>
<h1><a class="anchor" id="group_scb_spi_changelog"></a>
Changelog</h1>
<table class="doxtable">
<tr>
<th>Version</th><th>Changes</th><th>Reason for Change </th></tr>
<tr>
<td>2.10 </td><td>None. </td><td>SCB I2C driver updated.  </td></tr>
<tr>
<td rowspan="4">2.0 </td><td>Fixed SPI callback notification when error event occurred. </td><td>The SPI callback passed incorrect event value if error event occurred.  </td></tr>
<tr>
<td>Added parameters validation for public API. </td><td></td></tr>
<tr>
<td>Replaced variables that have limited range of values with enumerated types. </td><td></td></tr>
<tr>
<td>Added missing "cy_cb_" to the callback function type names. </td><td></td></tr>
<tr>
<td>1.0 </td><td>Initial version. </td><td></td></tr>
</table>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
API Reference</h2></td></tr>
<tr class="memitem:group__group__scb__spi__macros"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__spi__macros.html">Macros</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__scb__spi__functions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__spi__functions.html">Functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__scb__spi__data__structures"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__spi__data__structures.html">Data Structures</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__scb__spi__enums"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__spi__enums.html">Enumerated Types</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>Cypress Peripheral Driver Library (PDL)</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
