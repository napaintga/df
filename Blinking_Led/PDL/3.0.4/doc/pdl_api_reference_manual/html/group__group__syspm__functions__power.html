<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cypress Peripheral Driver Library (PDL): Power Modes</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="cypress_logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Cypress Peripheral Driver Library (PDL)
   &#160;<span id="projectnumber">Version 3.0.4.57</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__syspm__functions__power.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Power Modes<div class="ingroups"><a class="el" href="group__group__syspm.html">System Power Management (SysPm)</a> &raquo; <a class="el" href="group__group__syspm__functions.html">Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga4f9e1d22b5e0222f052c017cbe8a10d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__syspm__data__enumerates.html#ga601b1cb722cb091133caf33d8ab235ca">cy_en_syspm_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syspm__functions__power.html#ga4f9e1d22b5e0222f052c017cbe8a10d3">Cy_SysPm_Sleep</a> (<a class="el" href="group__group__syspm__data__enumerates.html#gaae6a9f528630a2d69bb70b3bced1f0ac">cy_en_syspm_waitfor_t</a> waitFor)</td></tr>
<tr class="memdesc:ga4f9e1d22b5e0222f052c017cbe8a10d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a CPU core to Sleep mode.  <a href="#ga4f9e1d22b5e0222f052c017cbe8a10d3">More...</a><br /></td></tr>
<tr class="separator:ga4f9e1d22b5e0222f052c017cbe8a10d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1211c6447be4863cb7ca807e2c9f98ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__syspm__data__enumerates.html#ga601b1cb722cb091133caf33d8ab235ca">cy_en_syspm_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syspm__functions__power.html#ga1211c6447be4863cb7ca807e2c9f98ee">Cy_SysPm_DeepSleep</a> (<a class="el" href="group__group__syspm__data__enumerates.html#gaae6a9f528630a2d69bb70b3bced1f0ac">cy_en_syspm_waitfor_t</a> waitFor)</td></tr>
<tr class="memdesc:ga1211c6447be4863cb7ca807e2c9f98ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a CPU core to the Deep Sleep mode.  <a href="#ga1211c6447be4863cb7ca807e2c9f98ee">More...</a><br /></td></tr>
<tr class="separator:ga1211c6447be4863cb7ca807e2c9f98ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2929e98b966d58c9246108a767ed7f53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__syspm__data__enumerates.html#ga601b1cb722cb091133caf33d8ab235ca">cy_en_syspm_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syspm__functions__power.html#ga2929e98b966d58c9246108a767ed7f53">Cy_SysPm_Hibernate</a> (void)</td></tr>
<tr class="memdesc:ga2929e98b966d58c9246108a767ed7f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the device into Hibernate mode.  <a href="#ga2929e98b966d58c9246108a767ed7f53">More...</a><br /></td></tr>
<tr class="separator:ga2929e98b966d58c9246108a767ed7f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2540970e6c27efa25752efc43da0d622"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syspm__functions__power.html#ga2540970e6c27efa25752efc43da0d622">Cy_SysPm_SetHibernateWakeupSource</a> (uint32_t wakeupSource)</td></tr>
<tr class="memdesc:ga2540970e6c27efa25752efc43da0d622"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configures sources to wake up the device from the Hibernate power mode.  <a href="#ga2540970e6c27efa25752efc43da0d622">More...</a><br /></td></tr>
<tr class="separator:ga2540970e6c27efa25752efc43da0d622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cb3a837b9c441f4806c7550e6a0b026"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syspm__functions__power.html#ga5cb3a837b9c441f4806c7550e6a0b026">Cy_SysPm_ClearHibernateWakeupSource</a> (uint32_t wakeupSource)</td></tr>
<tr class="memdesc:ga5cb3a837b9c441f4806c7550e6a0b026"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function disables a wakeup source that was previously configured to wake up the device from the hibernate power mode.  <a href="#ga5cb3a837b9c441f4806c7550e6a0b026">More...</a><br /></td></tr>
<tr class="separator:ga5cb3a837b9c441f4806c7550e6a0b026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ff9480e354c01a80b2597b1c16d8126"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__syspm__data__enumerates.html#ga601b1cb722cb091133caf33d8ab235ca">cy_en_syspm_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syspm__functions__power.html#ga8ff9480e354c01a80b2597b1c16d8126">Cy_SysPm_EnterLowPowerMode</a> (void)</td></tr>
<tr class="memdesc:ga8ff9480e354c01a80b2597b1c16d8126"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function switches only the supply regulators into Low Power mode.  <a href="#ga8ff9480e354c01a80b2597b1c16d8126">More...</a><br /></td></tr>
<tr class="separator:ga8ff9480e354c01a80b2597b1c16d8126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2d2dd20ca4ec0e37915c5883fe9db1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__syspm__data__enumerates.html#ga601b1cb722cb091133caf33d8ab235ca">cy_en_syspm_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syspm__functions__power.html#gae2d2dd20ca4ec0e37915c5883fe9db1d">Cy_SysPm_ExitLowPowerMode</a> (void)</td></tr>
<tr class="memdesc:gae2d2dd20ca4ec0e37915c5883fe9db1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exits the device from Low Power mode.  <a href="#gae2d2dd20ca4ec0e37915c5883fe9db1d">More...</a><br /></td></tr>
<tr class="separator:gae2d2dd20ca4ec0e37915c5883fe9db1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga827d8b12343108ea9de619cb1a9248bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syspm__functions__power.html#ga827d8b12343108ea9de619cb1a9248bd">Cy_SysPm_SleepOnExit</a> (bool enable)</td></tr>
<tr class="memdesc:ga827d8b12343108ea9de619cb1a9248bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configures the Sleep-on-exit feature of the core.  <a href="#ga827d8b12343108ea9de619cb1a9248bd">More...</a><br /></td></tr>
<tr class="separator:ga827d8b12343108ea9de619cb1a9248bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga4f9e1d22b5e0222f052c017cbe8a10d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f9e1d22b5e0222f052c017cbe8a10d3">&#9670;&nbsp;</a></span>Cy_SysPm_Sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__syspm__data__enumerates.html#ga601b1cb722cb091133caf33d8ab235ca">cy_en_syspm_status_t</a> Cy_SysPm_Sleep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__syspm__data__enumerates.html#gaae6a9f528630a2d69bb70b3bced1f0ac">cy_en_syspm_waitfor_t</a>&#160;</td>
          <td class="paramname"><em>waitFor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a CPU core to Sleep mode. </p>
<p>Puts the core into Sleep power mode, if none of callback functions were registered.</p>
<p>For more details about switching into Sleep power mode and debug, refer to the device TRM.</p>
<p>If at least one callback function with the CY_SYSPM_SLEEP type was registered, the next algorithm is executed: Prior to entering Sleep mode, all callback functions of the CY_SYSPM_SLEEP type with the CY_SYSPM_CHECK_READY parameter are called. This allows the driver to signal whether it is ready to enter the Low Power mode. If any of the callbacks of the CY_SYSPM_SLEEP type with the CY_SYSPM_CHECK_READY parameter returns CY_SYSPM_FAIL, the remaining callback of the CY_SYSPM_SLEEP type with the CY_SYSPM_CHECK_READY parameter calls are skipped. After CY_SYSPM_FAIL, all the CY_SYSPM_SLEEP callbacks with the CY_SYSPM_CHECK_FAIL parameter are executed. These are the callbacks of the CY_SYSPM_SLEEP type with the CY_SYSPM_CHECK_READY parameter that were previously executed before getting CY_SYSPM_FAIL. The Sleep mode is not entered and the <a class="el" href="group__group__syspm__functions__power.html#ga4f9e1d22b5e0222f052c017cbe8a10d3" title="Sets a CPU core to Sleep mode. ">Cy_SysPm_Sleep()</a> function returns CY_SYSPM_FAIL.</p>
<p>If all of the callbacks of the CY_SYSPM_SLEEP type with the CY_SYSPM_CHECK_READY parameter calls return CY_SYSPM_SUCCESS, then all callbacks of the CY_SYSPM_SLEEP type with the CY_SYSPM_CHECK_FAIL parameters calls are skipped. Also, all callbacks of the CY_SYSPM_SLEEP type and CY_SYSPM_BEFORE_TRANSITION parameter calls are executed, allowing the peripherals to prepare for Sleep. The CPU then enters Sleep mode. This is a CPU-centric power mode. This means that the CPU has entered Sleep mode and its main clock is removed. It is identical to Active from a peripheral point of view. Any enabled interrupt can cause a wakeup from Sleep mode.</p>
<p>After a wakeup from Sleep, all of the registered callbacks of the CY_SYSPM_SLEEP type and with the CY_SYSPM_AFTER_TRANSITION parameter are executed to return the peripherals to Active operation. The <a class="el" href="group__group__syspm__functions__power.html#ga4f9e1d22b5e0222f052c017cbe8a10d3" title="Sets a CPU core to Sleep mode. ">Cy_SysPm_Sleep()</a> function returns CY_SYSPM_SUCCESS. No callbacks of the CY_SYSPM_SLEEP type with the CY_SYSPM_BEFORE_TRANSITION parameter or callbacks of the CY_SYSPM_SLEEP type and CY_SYSPM_AFTER_TRANSITION parameter callbacks are executed if Sleep mode is not entered.</p>
<dl class="section note"><dt>Note</dt><dd>The last callback that returned CY_SYSPM_FAIL is not executed with the CY_SYSPM_CHECK_FAIL parameter because of the FAIL.</dd></dl>
<p>The return values from executed callback functions with the CY_SYSPM_CHECK_FAIL, CY_SYSPM_BEFORE_TRANSITION, and CY_SYSPM_AFTER_TRANSITION modes are ignored.</p>
<p><a class="el" href="group__group__syspm__data__enumerates.html#gae06cd8869fe61d709ad6145ca9f3cd63">cy_en_syspm_callback_mode_t</a>, except the CY_SYSPM_CHECK_READY, are ignored</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waitFor</td><td>Selects wait for action. See <a class="el" href="group__group__syspm__data__enumerates.html#gaae6a9f528630a2d69bb70b3bced1f0ac">cy_en_syspm_waitfor_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Entered status, see <a class="el" href="group__group__syspm__data__enumerates.html#ga601b1cb722cb091133caf33d8ab235ca">cy_en_syspm_status_t</a>.</dd></dl>
<dl class="section user"><dt>Side Effects</dt><dd>This function clears the Event Register of CM4 core after wakeup from WFE.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: there is a need to put the device into Sleep mode */</span></div><div class="line">    <span class="comment">/* Prepare the system for Sleep power mode here */</span></div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__syspm__data__enumerates.html#gga601b1cb722cb091133caf33d8ab235caaf00d22f1ee891a8a56f8bbf58132e775">CY_SYSPM_SUCCESS</a> != <a class="code" href="group__group__syspm__functions__power.html#ga4f9e1d22b5e0222f052c017cbe8a10d3">Cy_SysPm_Sleep</a>(<a class="code" href="group__group__syspm__data__enumerates.html#ggaae6a9f528630a2d69bb70b3bced1f0acadf47e50b6700c08b6f9e7e70bb525541">CY_SYSPM_WAIT_FOR_INTERRUPT</a>))</div><div class="line">    {</div><div class="line">        <span class="comment">/* System did not enter Sleep mode because some registered </span></div><div class="line"><span class="comment">        Sleep &quot;check ready&quot; callback returned a &quot;not success&quot; status */</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* if the program has reached here, the core is just woken up</span></div><div class="line"><span class="comment">         * from the Sleep mode</span></div><div class="line"><span class="comment">         */</span></div><div class="line">    }</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga1211c6447be4863cb7ca807e2c9f98ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1211c6447be4863cb7ca807e2c9f98ee">&#9670;&nbsp;</a></span>Cy_SysPm_DeepSleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__syspm__data__enumerates.html#ga601b1cb722cb091133caf33d8ab235ca">cy_en_syspm_status_t</a> Cy_SysPm_DeepSleep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__syspm__data__enumerates.html#gaae6a9f528630a2d69bb70b3bced1f0ac">cy_en_syspm_waitfor_t</a>&#160;</td>
          <td class="paramname"><em>waitFor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a CPU core to the Deep Sleep mode. </p>
<p>Puts the core into the Deep Sleep power mode. Prior to entering the Deep Sleep mode, all callbacks of the CY_SYSPM_DEEPSLEEP type with the CY_SYSPM_CHECK_READY parameter registered callbacks are called, allowing the driver to signal whether it is ready to enter the power mode. If any CY_SYSPM_DEEPSLEEP type with the CY_SYSPM_CHECK_READY parameter call returns CY_SYSPM_FAIL, the remaining callback CY_SYSPM_DEEPSLEEP type with the CY_SYSPM_CHECK_READY parameter calls are skipped. After a CY_SYSPM_FAIL, all of the callbacks of the CY_SYSPM_DEEPSLEEP type with the CY_SYSPM_CHECK_FAIL parameter are executed that correspond to the callbacks with CY_SYSPM_DEEPSLEEP type with CY_SYSPM_CHECK_READY parameter calls that occurred up to the point of failure. The Deep Sleep mode is not entered and the <a class="el" href="group__group__syspm__functions__power.html#ga1211c6447be4863cb7ca807e2c9f98ee" title="Sets a CPU core to the Deep Sleep mode. ">Cy_SysPm_DeepSleep()</a> function returns CY_SYSPM_FAIL.</p>
<p>If all callbacks of the CY_SYSPM_DEEPSLEEP type with the CY_SYSPM_CHECK_READY parameter calls return CY_SYSPM_SUCCESS, then all callbacks of the CY_SYSPM_DEEPSLEEP type with the CY_SYSPM_CHECK_FAIL parameter calls are skipped and all callbacks of the CY_SYSPM_DEEPSLEEP type with the CY_SYSPM_BEFORE_TRANSITION parameter calls are executed, allowing the peripherals to prepare for Deep Sleep. The Deep Sleep mode is then entered. Any enabled interrupt can cause a wakeup from the Deep Sleep mode.</p>
<dl class="section note"><dt>Note</dt><dd>The last callback which returned CY_SYSPM_FAIL is not executed with the CY_SYSPM_CHECK_FAIL parameter because of the FAIL.</dd></dl>
<p>The return values from executed callback functions with the CY_SYSPM_CHECK_FAIL, CY_SYSPM_BEFORE_TRANSITION, and CY_SYSPM_AFTER_TRANSITION modes are ignored.</p>
<p>If the firmware attempts to enter this mode before the system is ready (that is, when PWR_CONTROL.LPM_READY = 0), then the device will go into the (LP) Sleep mode instead and automatically enter Deep Sleep mode when the system is ready.</p>
<p>The system puts the whole device into Deep Sleep mode when all the processor(s) is (are) in Deep Sleep, there are no busy peripherals, the debugger is not active, and the Deep Sleep circuits are ready (PWR_CONTROL.LPM_READY=1).</p>
<p>The peripherals that do not need a clock or that receive a clock from their external interface (e.g. I2C/SPI) continue operating. All circuits using the current from Vccdpslp supply are under the current limitation, which is controlled by the Deep Sleep regulator.</p>
<p>Wakeup occurs when an interrupt asserts from a Deep Sleep active peripheral. For more details, see the corresponding peripheral's datasheet.</p>
<dl class="section note"><dt>Note</dt><dd>For multi-core devices, the second core, which did not participate in device wakeup, continues to execute the Deep Sleep instructions. Any Deep Sleep capable interrupt routed to this core can wake it.</dd></dl>
<p>For more details about switching into the Deep Sleep power mode and debug, refer to the device TRM.</p>
<p>A normal wakeup from the Deep Sleep power mode returns to either LPActive or Active, depending on the previous state and programmed behavior for the particular wakeup interrupt.</p>
<p>After wakeup from Deep Sleep, all of the registered callbacks with CY_SYSPM_DEEPSLEEP type with CY_SYSPM_AFTER_TRANSITION are executed to return peripherals to Active operation. The <a class="el" href="group__group__syspm__functions__power.html#ga1211c6447be4863cb7ca807e2c9f98ee" title="Sets a CPU core to the Deep Sleep mode. ">Cy_SysPm_DeepSleep()</a> function returns CY_SYSPM_SUCCESS. No callbacks are executed with CY_SYSPM_DEEPSLEEP type with CY_SYSPM_BEFORE_TRANSITION or CY_SYSPM_AFTER_TRANSITION parameter, if Deep Sleep mode was not entered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waitFor</td><td>Selects wait for action. See <a class="el" href="group__group__syspm__data__enumerates.html#gaae6a9f528630a2d69bb70b3bced1f0ac">cy_en_syspm_waitfor_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Side Effects</dt><dd>This side effect is applicable only for devices with UDB IP block available. You can obtain unpredictable behavior of the UDB block after the device wakeup from Deep Sleep. Unpredictable behavior scenario:<ul>
<li>The first core saves non-retained UDB configuration registers and goes into the Deep Sleep (<a class="el" href="group__group__syspm__functions__power.html#ga1211c6447be4863cb7ca807e2c9f98ee" title="Sets a CPU core to the Deep Sleep mode. ">Cy_SysPm_DeepSleep()</a> function).</li>
<li>These non-retained UDB configuration registers are modified in runtime by another (second) active core.</li>
<li>The second core saves non-retained UDB configuration registers and goes into the Deep Sleep (<a class="el" href="group__group__syspm__functions__power.html#ga1211c6447be4863cb7ca807e2c9f98ee" title="Sets a CPU core to the Deep Sleep mode. ">Cy_SysPm_DeepSleep()</a> function). These conditions save different values of the non-retained UDB configuration registers. The prevented scenario: on the first core wakeup, these registers are restored by the values saved on the first core. After the second core wakeup, these registers are "reconfigured" by the values saved on the second core. Be aware of this situation.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Side Effects</dt><dd>This function clears the Event Register of CM4 core after wakeup from WFE.</dd></dl>
<dl class="section user"><dt>Side Effects</dt><dd>This side effect is applicable only for rev-08 of the CY8CKIT-062. The function changes the slow and fast clock dividers to SYSPM_CLK_DIVIDER right before entering into Deep Sleep and restores these dividers after wakeup.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Entered status, see <a class="el" href="group__group__syspm__data__enumerates.html#ga601b1cb722cb091133caf33d8ab235ca">cy_en_syspm_status_t</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The FLL/PLL are not restored right before the CPU starts executing the instructions after Deep Sleep. This can affect the peripheral which is driven by PLL/FLL. Ensure that the PLL/FLL were properly restored (locked) after the wakeup from Deep Sleep. Refer to the <a class="el" href="group__group__sysclk.html">System Clock (SysClk)</a> driver documentation driver for the information how to read the PLL/FLL lock statuses.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: there is a need to put the device into Deep-Sleep mode */</span></div><div class="line">    <span class="comment">/* Prepare the system for Deep-Sleep power mode here */</span></div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__syspm__data__enumerates.html#gga601b1cb722cb091133caf33d8ab235caaf00d22f1ee891a8a56f8bbf58132e775">CY_SYSPM_SUCCESS</a> != <a class="code" href="group__group__syspm__functions__power.html#ga1211c6447be4863cb7ca807e2c9f98ee">Cy_SysPm_DeepSleep</a>(<a class="code" href="group__group__syspm__data__enumerates.html#ggaae6a9f528630a2d69bb70b3bced1f0acadf47e50b6700c08b6f9e7e70bb525541">CY_SYSPM_WAIT_FOR_INTERRUPT</a>))</div><div class="line">    {</div><div class="line">        <span class="comment">/* System did not enter Deep-Sleep mode because some registered </span></div><div class="line"><span class="comment">        Deep-Sleep &quot;check ready&quot; callback returned a &quot;not success&quot; status */</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* if the program has reached here, the core is just woken up</span></div><div class="line"><span class="comment">         * from the Deep-Sleep mode</span></div><div class="line"><span class="comment">         */</span></div><div class="line">    }</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga2929e98b966d58c9246108a767ed7f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2929e98b966d58c9246108a767ed7f53">&#9670;&nbsp;</a></span>Cy_SysPm_Hibernate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__syspm__data__enumerates.html#ga601b1cb722cb091133caf33d8ab235ca">cy_en_syspm_status_t</a> Cy_SysPm_Hibernate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the device into Hibernate mode. </p>
<p>Puts the core into the Hibernate power mode. Prior to entering Hibernate mode, all callbacks of the CY_SYSPM_HIBERNATE type are executed. First, callbacks of the CY_SYSPM_HIBERNATE type and with CY_SYSPM_CHECK_READY parameter are called, allowing the driver to signal if it is not ready to enter the power mode. If any of the callbacks of the CY_SYSPM_HIBERNATE type with the CY_SYSPM_CHECK_READY parameter call returns CY_SYSPM_FAIL, the remaining CY_SYSPM_HIBERNATE callbacks with the CY_SYSPM_CHECK_READY parameter calls are skipped. After CY_SYSPM_FAIL, all of the CY_SYSPM_HIBERNATE callbacks with CY_SYSPM_CHECK_FAIL parameter are executed that correspond to the CY_SYSPM_HIBERNATE callbacks with CY_SYSPM_CHECK_READY parameter calls that occurred up to the point of failure. Hibernate mode is not entered and the <a class="el" href="group__group__syspm__functions__power.html#ga2929e98b966d58c9246108a767ed7f53" title="Sets the device into Hibernate mode. ">Cy_SysPm_Hibernate()</a> function returns CY_SYSPM_FAIL.</p>
<p>If all CY_SYSPM_HIBERNATE callbacks with the CY_SYSPM_CHECK_READY parameter calls return CY_SYSPM_SUCCESS, then all CY_SYSPM_HIBERNATE callbacks with CY_SYSPM_CHECK_FAIL calls are skipped and all CY_SYSPM_HIBERNATE callbacks CY_SYSPM_BEFORE_TRANSITION parameter calls are executed allowing the peripherals to prepare for Hibernate. The I/O output state is frozen and Hibernate mode is then entered. In Hibernate mode, all internal supplies are off and no internal state is retained. There is no handshake with the CPUs and the chip will enter Hibernate immediately.</p>
<p>The I/O output state is frozen and Hibernate mode is then entered. In Hibernate mode, all internal supplies are off and no internal state is retained. For multi-core devices there is no handshake with the CPUs and the chip will enter Hibernate power mode immediately.</p>
<dl class="section note"><dt>Note</dt><dd>The last callback that returned CY_SYSPM_FAIL is not executed with the CY_SYSPM_CHECK_FAIL parameter because of the FAIL.</dd></dl>
<p>The return values from executed callback functions with the CY_SYSPM_CHECK_FAIL, CY_SYSPM_BEFORE_TRANSITION, and CY_SYSPM_AFTER_TRANSITION modes are ignored.</p>
<p>A wakeup from Hibernate is triggered by toggling the wakeup pin(s), a WDT match, or back-up domain alarm expiration, depending on how the they were configured. A wakeup causes a normal boot procedure. To configure the wakeup pin(s), a Digital Input Pin must be configured, and resistively pulled up or down to the inverse state of the wakeup polarity. To distinguish a wakeup from Hibernate mode and a general reset event, the <a class="el" href="group__group__syslib__functions.html#gac8aa61d2f8052886c676f4f592d1693d" title="The function returns the cause for the latest reset(s) that occurred in the system. ">Cy_SysLib_GetResetReason()</a> function can be used. The wakeup pin and low-power comparators are active-low by default. The wakeup pin or the LPComparators polarity can be changed with the <a class="el" href="group__group__syspm__functions__power.html#ga2540970e6c27efa25752efc43da0d622">Cy_SysPm_SetHibernateWakeupSource()</a> function. This function call will not return if Hibernate mode is entered. The CY_SYSPM_HIBERNATE callbacks with the CY_SYSPM_AFTER_TRANSITION parameter are never executed.</p>
<p>This function freezes the I/O cells implicitly. Entering Hibernate mode before freezing the I/O cells is not possible. The I/O cells remain frozen after waking from Hibernate mode until the firmware unfreezes them with a <a class="el" href="group__group__syspm__functions__iofreeze.html#ga5df20917d995755606672fac961e8e9b">Cy_SysPm_IoUnfreeze()</a> function call.</p>
<dl class="section return"><dt>Returns</dt><dd>Entered status, see <a class="el" href="group__group__syspm__data__enumerates.html#ga601b1cb722cb091133caf33d8ab235ca">cy_en_syspm_status_t</a>.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: there is a need to put the device into the Hibernate mode */</span></div><div class="line">    <span class="comment">/* Prepare the system for Hibernate mode here */</span></div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__syspm__data__enumerates.html#gga601b1cb722cb091133caf33d8ab235caaf00d22f1ee891a8a56f8bbf58132e775">CY_SYSPM_SUCCESS</a> != <a class="code" href="group__group__syspm__functions__power.html#ga2929e98b966d58c9246108a767ed7f53">Cy_SysPm_Hibernate</a>())</div><div class="line">    {</div><div class="line">        <span class="comment">/* System did not enter Hibernate mode because some registered </span></div><div class="line"><span class="comment">        Hibernate &quot;check ready&quot; callback returned a &quot;not success&quot; status */</span></div><div class="line">    }</div><div class="line">    <span class="comment">/* You will never get CY_SYSPM_SUCCESS here because in case of successful</span></div><div class="line"><span class="comment">     * hibernating the returning into active mode goes through the system reset.</span></div><div class="line"><span class="comment">     */</span></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga2540970e6c27efa25752efc43da0d622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2540970e6c27efa25752efc43da0d622">&#9670;&nbsp;</a></span>Cy_SysPm_SetHibernateWakeupSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SysPm_SetHibernateWakeupSource </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>wakeupSource</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configures sources to wake up the device from the Hibernate power mode. </p>
<p>Such sources can be wakeup pins, LPComparators, Watchdog (WDT) interrupt, or a Real-Time clock (RTC) alarm (interrupt).</p>
<p>Wakeup pins:</p>
<p>A wakeup is supported by up to two pins with programmable polarity. These pins may be connected to the I/O pins or on-chip peripherals under some conditions. Setting the wakeup pin to this level will cause a wakeup from Hibernate mode. The wakeup pins are active/low by default.</p>
<p>LPComparators:</p>
<p>A wakeup is supported by up to two LPComps with programmable polarity. These LPComp may be connected to the I/O pins or on-chip peripherals under some conditions. Setting the LPComp to this level will cause a wakeup from Hibernate mode. The wakeup LPComp are active-low by default.</p>
<dl class="section note"><dt>Note</dt><dd>The low-power comparators should be configured and enabled before switching into the hibernate low power mode. Refer to the LPComp driver description for more details.</dd></dl>
<p>Watchdog Timer:</p>
<dl class="section note"><dt>Note</dt><dd>The WDT should be configured and enabled before entering into the Hibernate power mode.</dd></dl>
<p>A wakeup is performed by a WDT interrupt and a normal boot procedure after a device reset. The device can wake up from Hibernate after a WDT device reset, if the WDT was configured to wake up, the device on its interrupt and WDT was enabled.</p>
<p>Real-time Clock:</p>
<p>A wakeup is performed by the RTC alarm and a normal boot procedure after a device reset. Refer to the Real-Time Clock (RTC) driver description for more details.</p>
<p>For information about wakeup sources and their assignment in the specific families devices, refer to the appropriate device TRM.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wakeupSource</td><td>The source to be configured as a wakeup source from the Hibernate power mode, see <a class="el" href="group__group__syspm__data__enumerates.html#ga369b76c2e602edf09ede9f8f804e066e">cy_en_syspm_hibernate_wakeup_source_t</a>. The input parameters values can be ORed. For example, if you want to set LPComp0 (active high) and WDT, call this function: Cy_SysPm_SetHibernateWakeupSource(CY_SYSPM_HIBERNATE_LPCOMP0_HIGH | CY_SYSPM_HIBERNATE_WDT).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not call this function with different polarity levels for the same wakeup source. For example, do not call a function like this: Cy_SysPm_SetHibernateWakeupSource(CY_SYSPM_HIBERNATE_LPCOMP0_LOW, CY_SYSPM_HIBERNATE_LPCOMP0_HIGH);</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: there is a need to configure all desired Hibernate wake up sources */</span></div><div class="line">    <a class="code" href="group__group__syspm__functions__power.html#ga2540970e6c27efa25752efc43da0d622">Cy_SysPm_SetHibernateWakeupSource</a>(<a class="code" href="group__group__syspm__data__enumerates.html#gga369b76c2e602edf09ede9f8f804e066ea21ccdb0596ce5097ca95c700e46e24cf">CY_SYSPM_HIBERNATE_LPCOMP0_LOW</a> | <a class="code" href="group__group__syspm__data__enumerates.html#gga369b76c2e602edf09ede9f8f804e066eaf1aa6dc689e0656b696f0b81f7e323c7">CY_SYSPM_HIBERNATE_RTC_ALARM</a> | <a class="code" href="group__group__syspm__data__enumerates.html#gga369b76c2e602edf09ede9f8f804e066eacb2a6e7c498e704f86f2315833feddcf">CY_SYSPM_HIBERNATE_PIN1_HIGH</a>);</div><div class="line">    </div><div class="line">    <span class="comment">/* Scenario: the LPComp0 wake up polarity was Low and there is a need to set it to High */</span></div><div class="line">    <a class="code" href="group__group__syspm__functions__power.html#ga2540970e6c27efa25752efc43da0d622">Cy_SysPm_SetHibernateWakeupSource</a>(<a class="code" href="group__group__syspm__data__enumerates.html#gga369b76c2e602edf09ede9f8f804e066ea5dbe774244382f2a853050d758a58219">CY_SYSPM_HIBERNATE_LPCOMP0_HIGH</a>);</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga5cb3a837b9c441f4806c7550e6a0b026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cb3a837b9c441f4806c7550e6a0b026">&#9670;&nbsp;</a></span>Cy_SysPm_ClearHibernateWakeupSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SysPm_ClearHibernateWakeupSource </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>wakeupSource</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function disables a wakeup source that was previously configured to wake up the device from the hibernate power mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wakeupSource</td><td>For the source to be disabled, see <a class="el" href="group__group__syspm__data__enumerates.html#ga369b76c2e602edf09ede9f8f804e066e">cy_en_syspm_hibernate_wakeup_source_t</a>. The input parameters values can be ORed. For example, if you want to disable LPComp0 (active high) and WDT call this function: Cy_SysPm_ClearHibernateWakeupSource(CY_SYSPM_HIBERNATE_LPCOMP0_HIGH | CY_SYSPM_HIBERNATE_WDT).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: there is a need to disable the LPComp0 wake up source */</span></div><div class="line">    <a class="code" href="group__group__syspm__functions__power.html#ga5cb3a837b9c441f4806c7550e6a0b026">Cy_SysPm_ClearHibernateWakeupSource</a>(<a class="code" href="group__group__syspm__data__enumerates.html#gga369b76c2e602edf09ede9f8f804e066ea5dbe774244382f2a853050d758a58219">CY_SYSPM_HIBERNATE_LPCOMP0_HIGH</a>);</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga8ff9480e354c01a80b2597b1c16d8126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ff9480e354c01a80b2597b1c16d8126">&#9670;&nbsp;</a></span>Cy_SysPm_EnterLowPowerMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__syspm__data__enumerates.html#ga601b1cb722cb091133caf33d8ab235ca">cy_en_syspm_status_t</a> Cy_SysPm_EnterLowPowerMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function switches only the supply regulators into Low Power mode. </p>
<p>You must configure clocks and/or peripherals to meet current load limitations in LP Active. For more details about power modes and current load limitations refer to the device technical reference manual (TRM).</p>
<p>The LPActive mode is similar to the Active mode. The difference is that the current is limited and some functions have limited features/performance.</p>
<p>The key feature of the Low Power mode is the limited current. Restrictions are placed on the clock frequencies and allow the peripherals to achieve a current limit.</p>
<p>Before entering Low Power mode, you must configure the system so the total current drawn from Vccd is less that the value presented in the technical reference manual (TRM). Refer to the TRM for the maximum load for low power operation and clock limitations in Low Power mode with different core supply regulator voltages.</p>
<ul>
<li>Peripherals can use the knowledge of the LPActive mode to make trade-offs that consume less current. For more details, see the corresponding peripherals' datasheet.</li>
<li>High-speed clock sources are available with the appropriate pre-divider settings to limit the system current. Refer to the TRM for the maximum frequency values for low power operation using different Core Regulators' output voltages.</li>
</ul>
<p>This function puts the device into Low Power mode. Prior to entering Low Power mode, all the registered CY_SYSPM_ENTER_LOWPOWER_MODE callbacks with CY_SYSPM_CHECK_READY parameter are called. This allows the driver to signal if it is not ready to enter Low Power mode. If any CY_SYSPM_ENTER_LOWPOWER_MODE callbacks with the CY_SYSPM_CHECK_READY parameter call returns CY_SYSPM_FAIL, the remaining CY_SYSPM_ENTER_LOWPOWER_MODE callbacks with the CY_SYSPM_CHECK_READY parameter calls are skipped.</p>
<p>After a CY_SYSPM_FAIL, all of the CY_SYSPM_ENTER_LOWPOWER_MODE callbacks with CY_SYSPM_CHECK_FAIL parameter are executed that correspond to the CY_SYSPM_ENTER_LOWPOWER_MODE callbacks with CY_SYSPM_CHECK_READY parameter calls that occurred up to the point of failure. Low Power mode is not entered and the <a class="el" href="group__group__syspm__functions__power.html#ga8ff9480e354c01a80b2597b1c16d8126" title="This function switches only the supply regulators into Low Power mode. ">Cy_SysPm_EnterLowPowerMode()</a> function returns CY_SYSPM_FAIL.</p>
<p>If all CY_SYSPM_ENTER_LOWPOWER_MODE callbacks with the CY_SYSPM_CHECK_READY parameter calls return CY_SYSPM_SUCCESS, then all CY_SYSPM_ENTER_LOWPOWER_MODE callbacks with CY_SYSPM_CHECK_FAIL calls are skipped and all CY_SYSPM_ENTER_LOWPOWER_MODE callbacks with the CY_SYSPM_BEFORE_TRANSITION parameter calls are executed. This allows the peripherals to prepare for low power. Low Power mode is then entered.</p>
<p>After entering Low Power mode, all of the registered CY_SYSPM_ENTER_LOWPOWER_MODE callbacks with the CY_SYSPM_AFTER_TRANSITION parameter are executed to complete preparing the peripherals for low power operation. The <a class="el" href="group__group__syspm__functions__power.html#ga8ff9480e354c01a80b2597b1c16d8126" title="This function switches only the supply regulators into Low Power mode. ">Cy_SysPm_EnterLowPowerMode()</a> function returns CY_SYSPM_SUCCESS. No CY_SYSPM_ENTER_LOWPOWER_MODE callbacks with the CY_SYSPM_BEFORE_TRANSITION or CY_SYSPM_AFTER_TRANSITION parameter are executed, if Low Power mode is not entered.</p>
<dl class="section note"><dt>Note</dt><dd>The last callback that returned CY_SYSPM_FAIL is not executed with the CY_SYSPM_CHECK_FAIL parameter because of the FAIL.</dd></dl>
<p>The return values from executed callback functions with the CY_SYSPM_CHECK_FAIL, CY_SYSPM_BEFORE_TRANSITION, and CY_SYSPM_AFTER_TRANSITION modes are ignored.</p>
<dl class="section note"><dt>Note</dt><dd>The callbacks are not executed if the device is already not in Low Power mode.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="group__group__syspm__data__enumerates.html#ga601b1cb722cb091133caf33d8ab235ca">cy_en_syspm_status_t</a>. <br />
 CY_SYSPM_SUCCESS - Entered the LPActive mode or the device is already in LPActive.<br />
 CY_SYSPM_FAIL - The LPActive mode is not entered or low power circuits are not ready to enter Low Power mode.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: there is a need to put the device into the Low-Power mode */</span></div><div class="line">    <span class="comment">/* Prepare the system for Low Power mode entering - reconfigure/switch off </span></div><div class="line"><span class="comment">     * some used peripherals to match the power consumption restrictions</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__syspm__data__enumerates.html#gga601b1cb722cb091133caf33d8ab235caaf00d22f1ee891a8a56f8bbf58132e775">CY_SYSPM_SUCCESS</a> != <a class="code" href="group__group__syspm__functions__power.html#ga8ff9480e354c01a80b2597b1c16d8126">Cy_SysPm_EnterLowPowerMode</a>())</div><div class="line">    {</div><div class="line">        <span class="comment">/* System did not enter Low-Power mode because either the low power </span></div><div class="line"><span class="comment">        circuits are not ready to enter into the Low-Power mode or some registered </span></div><div class="line"><span class="comment">        Enter-low-power-mode &quot;check ready&quot; callback returned a </span></div><div class="line"><span class="comment">        &quot;not success&quot; status */</span></div><div class="line">    }</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gae2d2dd20ca4ec0e37915c5883fe9db1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2d2dd20ca4ec0e37915c5883fe9db1d">&#9670;&nbsp;</a></span>Cy_SysPm_ExitLowPowerMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__syspm__data__enumerates.html#ga601b1cb722cb091133caf33d8ab235ca">cy_en_syspm_status_t</a> Cy_SysPm_ExitLowPowerMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exits the device from Low Power mode. </p>
<p>Returns the device to the Active mode. In the Active power mode, the operating current can be increased to the normal mode limit. The clock frequencies also can be increased to the normal mode limit. Refer to the device TRM for the current and frequency limitations in the Active power mode.</p>
<p>Prior to exiting Low Power mode, all the registered CY_SYSPM_EXIT_LOWPOWER_MODE callbacks with the CY_SYSPM_CHECK_READY parameter are called. This allows the driver to signal if it is not ready to exit Low Power mode. If any CY_SYSPM_EXIT_LOWPOWER_MODE callbacks with the CY_SYSPM_CHECK_READY parameter call returns CY_SYSPM_FAIL, the remaining CY_SYSPM_EXIT_LOWPOWER_MODE callbacks with the CY_SYSPM_CHECK_READY parameter calls are skipped. After a CY_SYSPM_FAIL, all of the CY_SYSPM_EXIT_LOWPOWER_MODE callbacks with CY_SYSPM_CHECK_FAIL parameter are executed that correspond to the CY_SYSPM_EXIT_LOWPOWER_MODE callbacks with CY_SYSPM_CHECK_READY parameter calls that occurred up to the point of failure. Active mode is not entered and the <a class="el" href="group__group__syspm__functions__power.html#gae2d2dd20ca4ec0e37915c5883fe9db1d" title="Exits the device from Low Power mode. ">Cy_SysPm_ExitLowPowerMode()</a> function returns CY_SYSPM_FAIL.</p>
<p>If all CY_SYSPM_EXIT_LOWPOWER_MODE callbacks with CY_SYSPM_CHECK_READY calls return CY_SYSPM_SUCCESS, then all the CY_SYSPM_EXIT_LOWPOWER_MODE callbacks with the CY_SYSPM_CHECK_FAIL parameter calls are skipped and all CY_SYSPM_EXIT_LOWPOWER_MODE callbacks with the CY_SYSPM_BEFORE_TRANSITION parameter calls are executed allowing the peripherals to prepare for Active mode. Low Power mode is then exited.</p>
<p>After exiting Low Power mode, all of the registered callbacks that have type CY_SYSPM_EXIT_LOWPOWER_MODE are executed with the CY_SYSPM_AFTER_TRANSITION parameter to complete preparing the peripherals for Active mode operation. The <a class="el" href="group__group__syspm__functions__power.html#gae2d2dd20ca4ec0e37915c5883fe9db1d" title="Exits the device from Low Power mode. ">Cy_SysPm_ExitLowPowerMode()</a> function returns CY_SYSPM_SUCCESS. No CY_SYSPM_EXIT_LOWPOWER_MODE callbacks with the CY_SYSPM_BEFORE_TRANSITION or CY_SYSPM_AFTER_TRANSITION parameter are executed if Low Power mode is not exited.</p>
<dl class="section note"><dt>Note</dt><dd>The last callback that returned CY_SYSPM_FAIL is not executed with the CY_SYSPM_CHECK_FAIL parameter because of the FAIL.</dd></dl>
<p>The return values from executed callback functions with the CY_SYSPM_CHECK_FAIL, CY_SYSPM_BEFORE_TRANSITION, and CY_SYSPM_AFTER_TRANSITION modes are ignored.</p>
<dl class="section note"><dt>Note</dt><dd>The callbacks are not executed if the device is not already in Low Power mode.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="group__group__syspm__data__enumerates.html#ga601b1cb722cb091133caf33d8ab235ca">cy_en_syspm_status_t</a>. <br />
 CY_SYSPM_SUCCESS - Exited from the LPActive power mode, or the device is already in Active mode. <br />
 CY_SYSPM_FAIL - Exit from the LPActive mode is not done.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function blocks as it waits until Active Reference is ready to enter to the normal mode.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: there is a need to put the device out of the Low-Power mode */</span></div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__syspm__data__enumerates.html#gga601b1cb722cb091133caf33d8ab235caaf00d22f1ee891a8a56f8bbf58132e775">CY_SYSPM_SUCCESS</a> != <a class="code" href="group__group__syspm__functions__power.html#gae2d2dd20ca4ec0e37915c5883fe9db1d">Cy_SysPm_ExitLowPowerMode</a>())</div><div class="line">    {</div><div class="line">        <span class="comment">/* System did not enter Low-Power mode because some registered </span></div><div class="line"><span class="comment">        Exit-LP-mode &quot;check ready&quot; callback returned a &quot;not success&quot; status */</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* Reconfigure/switch on the peripherals </span></div><div class="line"><span class="comment">         * with relaxed power consumption restrictions</span></div><div class="line"><span class="comment">         */</span></div><div class="line">    }</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga827d8b12343108ea9de619cb1a9248bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga827d8b12343108ea9de619cb1a9248bd">&#9670;&nbsp;</a></span>Cy_SysPm_SleepOnExit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SysPm_SleepOnExit </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configures the Sleep-on-exit feature of the core. </p>
<p>This API sets the SLEEPONEXIT bit of the SCR register.</p>
<p>When the Sleep-on-exit feature is enabled (SLEEPONEXIT bit is set), the core wakes up to service the interrupt and then immediately goes back to sleep. Because of this, the unstacking process is not carried out, so this feature is useful for the interrupt driven application and helps to reduce the unnecessary stack push and pop operations. The core does not go to sleep if the interrupt handler returns to another interrupt handler (nested interrupt). You can use this feature in applications that require only the core to run when an interrupt occurs.</p>
<p>When the Sleep-on-exit feature is disabled (SLEEPONEXIT bit is cleared), the core returns back to the main thread after servicing the interrupt without going back to sleep.</p>
<p>Refer to the ARM documentation about the Sleep-on-exit feature and SLEEPONEXIT of the SCR register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>true - enable Sleep-on-exit feature <br />
 false - disable Sleep-on-exit feature.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: there is a need to enable Sleep-on-exit feature */</span></div><div class="line">    <a class="code" href="group__group__syspm__functions__power.html#ga827d8b12343108ea9de619cb1a9248bd">Cy_SysPm_SleepOnExit</a>(<span class="keyword">true</span>);</div><div class="line">    </div><div class="line">    <span class="comment">/* Prepare the core for Sleep */</span></div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__syspm__data__enumerates.html#gga601b1cb722cb091133caf33d8ab235caaf00d22f1ee891a8a56f8bbf58132e775">CY_SYSPM_SUCCESS</a> == <a class="code" href="group__group__syspm__functions__power.html#ga4f9e1d22b5e0222f052c017cbe8a10d3">Cy_SysPm_Sleep</a>(<a class="code" href="group__group__syspm__data__enumerates.html#ggaae6a9f528630a2d69bb70b3bced1f0acadf47e50b6700c08b6f9e7e70bb525541">CY_SYSPM_WAIT_FOR_INTERRUPT</a>))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Now the core is in sleep. </span></div><div class="line"><span class="comment">        * The core wakes up to service the interrupt and then immediately goes </span></div><div class="line"><span class="comment">        * back to sleep.*/</span> </div><div class="line">    }</div><div class="line">        </div><div class="line">    <span class="comment">/* Scenario: there is a need to disable Sleep-on-exit after it was enabled</span></div><div class="line"><span class="comment">    * Call Cy_SysPm_SleepOnExit(false) in the interrupt handler */</span></div><div class="line">        </div></div><!-- fragment --></dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>Cypress Peripheral Driver Library (PDL)</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
