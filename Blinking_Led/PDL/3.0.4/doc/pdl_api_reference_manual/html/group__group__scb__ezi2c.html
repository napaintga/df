<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cypress Peripheral Driver Library (PDL): EZI2C (SCB)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="cypress_logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Cypress Peripheral Driver Library (PDL)
   &#160;<span id="projectnumber">Version 3.0.4.57</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__scb__ezi2c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">API Reference</a>  </div>
  <div class="headertitle">
<div class="title">EZI2C (SCB)<div class="ingroups"><a class="el" href="group__group__scb.html">Serial Communication Block (SCB)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p>Driver API for EZI2C Slave Peripheral. </p>
<p>I2C - The Inter-Integrated Circuit (I2C) bus is an industry-standard. The two-wire hardware interface was developed by Philips Semiconductors (now NXP Semiconductors).</p>
<p>The EZI2C slave peripheral driver provides an API to implement the I2C slave device based on the SCB hardware block. This slave device emulates a common I2C EEPROM interface that acts like dual-port memory between the external master and your code. I2C devices based on the SCB hardware are compatible with the I2C Standard mode, Fast mode, and Fast mode Plus specifications, as defined in the I2C bus specification.</p>
<p>Features:</p><ul>
<li>An industry-standard I2C bus interface</li>
<li>Supports standard data rates of 100/400/1000 kbps</li>
<li>Emulates a common I2C EEPROM Interface</li>
<li>Acts like dual-port memory between the external master and your code</li>
<li>Supports Hardware Address Match</li>
<li>Supports two hardware addresses with separate buffers</li>
<li>Supports Wake from Deep Sleep on address match</li>
<li>Simple to set up and use; does not require calling EZI2C API at run time.</li>
</ul>
<h1><a class="anchor" id="group_scb_ezi2c_configuration"></a>
Configuration Considerations</h1>
<p>The EZI2C slave driver configuration can be divided to number of sequential steps listed below:</p><ul>
<li><a class="el" href="group__group__scb__ezi2c.html#group_scb_ezi2c_config">Configure EZI2C slave</a></li>
<li><a class="el" href="group__group__scb__ezi2c.html#group_scb_ezi2c_pins">Assign and Configure Pins</a></li>
<li><a class="el" href="group__group__scb__ezi2c.html#group_scb_ezi2c_clock">Assign Clock Divider</a></li>
<li><a class="el" href="group__group__scb__ezi2c.html#group_scb_ezi2c_data_rate">Configure Data Rate</a></li>
<li><a class="el" href="group__group__scb__ezi2c.html#group_scb_ezi2c_intr">Configure Interrupt</a></li>
<li><a class="el" href="group__group__scb__ezi2c.html#group_scb_ezi2c_enable">Enable EZI2C slave</a></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>EZI2C slave driver is built on top of the SCB hardware block. The SCB3 instance is used as an example for all code snippets. Modify the code to match your design.</dd></dl>
<h2><a class="anchor" id="group_scb_ezi2c_config"></a>
Configure EZI2C slave</h2>
<p>To set up the EZI2C slave driver, provide the configuration parameters in the <a class="el" href="structcy__stc__scb__ezi2c__config__t.html">cy_stc_scb_ezi2c_config_t</a> structure. The primary slave address slaveAddress1 must be provided. The other parameters are optional for operation. To initialize the driver, call <a class="el" href="group__group__scb__ezi2c__general__functions.html#gaafe61aa4c2931975a8698afa46717b97">Cy_SCB_EZI2C_Init</a> function providing a pointer to the filled <a class="el" href="structcy__stc__scb__ezi2c__config__t.html">cy_stc_scb_ezi2c_config_t</a> structure and allocated <a class="el" href="structcy__stc__scb__ezi2c__context__t.html">cy_stc_scb_ezi2c_context_t</a>.</p>
<div class="fragment"><div class="line"><span class="comment">/* Allocate context for EZI2C operation */</span></div><div class="line"><a class="code" href="structcy__stc__scb__ezi2c__context__t.html">cy_stc_scb_ezi2c_context_t</a> ezI2cContext;</div><div class="line"></div><div class="line"><span class="comment">/* Populate configuration structure */</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="structcy__stc__scb__ezi2c__config__t.html">cy_stc_scb_ezi2c_config_t</a> ezI2cConfig =</div><div class="line">{</div><div class="line">    .<a class="code" href="structcy__stc__scb__ezi2c__config__t.html#aa3405d940eb60a40f7de1580eb391c71">numberOfAddresses</a> = <a class="code" href="group__group__scb__ezi2c__enums.html#gga5e20e1c00a75b3467305aa839271697aa88d5060e586a93a7e1c77885dee8c5cf">CY_SCB_EZI2C_ONE_ADDRESS</a>,</div><div class="line">    .slaveAddress1     = 0x08U,</div><div class="line">    .slaveAddress2     = 0x00U,</div><div class="line">    .subAddressSize    = <a class="code" href="group__group__scb__ezi2c__enums.html#gga2a4845448404203987f881e2e907feffa313bce9b46a4ce11f0d2891842e98ee6">CY_SCB_EZI2C_SUB_ADDR8_BITS</a>,</div><div class="line">    .enableWakeFromSleep = <span class="keyword">false</span>,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* Configure EZI2C slave */</span></div><div class="line">(void) <a class="code" href="group__group__scb__ezi2c__general__functions.html#gaafe61aa4c2931975a8698afa46717b97">Cy_SCB_EZI2C_Init</a>(SCB3, &amp;ezI2cConfig, &amp;ezI2cContext);</div></div><!-- fragment --><p> Set up the EZI2C slave buffer before enabling its operation by using <a class="el" href="group__group__scb__ezi2c__slave__functions.html#ga37de7020a41bff6ee0ad54af0a8be36e">Cy_SCB_EZI2C_SetBuffer1</a> for the primary slave address and <a class="el" href="group__group__scb__ezi2c__slave__functions.html#ga2435d7a2b8e0d069e6ae1f2686e64be8">Cy_SCB_EZI2C_SetBuffer2</a> for the secondary (if the secondary is enabled).</p>
<div class="fragment"><div class="line"><span class="comment">/* Allocate buffer for EZI2C operation */</span></div><div class="line"><span class="preprocessor">#define BUFFER_SIZE (128UL)</span></div><div class="line">uint8_t bufferAddr1[BUFFER_SIZE];</div><div class="line"></div><div class="line"><span class="comment">/* Configure buffer for communication with master */</span></div><div class="line"><a class="code" href="group__group__scb__ezi2c__slave__functions.html#ga37de7020a41bff6ee0ad54af0a8be36e">Cy_SCB_EZI2C_SetBuffer1</a>(SCB3, bufferAddr1, BUFFER_SIZE, BUFFER_SIZE, &amp;ezI2cContext);</div></div><!-- fragment --> <h2><a class="anchor" id="group_scb_ezi2c_pins"></a>
Assign and Configure Pins</h2>
<p>Only dedicated SCB pins can be used for I2C operation. The HSIOM register must be configured to connect the block to the pins. Also the I2C pins must be configured in Open-Drain, Drives Low mode (this pin configuration implies usage of external pull-up resistors):</p>
<div class="fragment"><div class="line"><span class="comment">/* Assign pins for EZI2C on SCB3: P6[0] and P6[1] */</span></div><div class="line"><span class="preprocessor">#define EZI2C_PORT      (P6_0_PORT)</span></div><div class="line"><span class="preprocessor">#define EZI2C_SCL_NUM   (P6_0_NUM)</span></div><div class="line"><span class="preprocessor">#define EZI2C_SDA_NUM   (P6_1_NUM)</span></div><div class="line"></div><div class="line"><span class="comment">/* Connect SCB3 I2C function to pins */</span></div><div class="line"><a class="code" href="group__group__gpio__functions__init.html#ga83a06264feed0e1042671a74339ea155">Cy_GPIO_SetHSIOM</a>(EZI2C_PORT, EZI2C_SCL_NUM, P6_0_SCB3_I2C_SCL);</div><div class="line"><a class="code" href="group__group__gpio__functions__init.html#ga83a06264feed0e1042671a74339ea155">Cy_GPIO_SetHSIOM</a>(EZI2C_PORT, EZI2C_SDA_NUM, P6_1_SCB3_I2C_SDA);</div><div class="line"></div><div class="line"><span class="comment">/* Configure pins for I2C operation */</span></div><div class="line"><a class="code" href="group__group__gpio__functions__gpio.html#ga97e64dc8c45e7cd73e3012100d03b1fd">Cy_GPIO_SetDrivemode</a>(EZI2C_PORT, EZI2C_SCL_NUM, <a class="code" href="group__group__gpio__drive_modes.html#ga4c713a8cb3c1e444153829c5ea94b34f">CY_GPIO_DM_OD_DRIVESLOW</a>);</div><div class="line"><a class="code" href="group__group__gpio__functions__gpio.html#ga97e64dc8c45e7cd73e3012100d03b1fd">Cy_GPIO_SetDrivemode</a>(EZI2C_PORT, EZI2C_SDA_NUM, <a class="code" href="group__group__gpio__drive_modes.html#ga4c713a8cb3c1e444153829c5ea94b34f">CY_GPIO_DM_OD_DRIVESLOW</a>);</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>The alternative pins configuration is Resistive Pull-ups which implies usage internal pull-up resistors. This configuration is not recommended because resistor value is fixed and cannot be used for all supported data rates. Refer to device datasheet parameter RPULLUP for resistor value specifications.</dd></dl>
<h2><a class="anchor" id="group_scb_ezi2c_clock"></a>
Assign Clock Divider</h2>
<p>The clock source must be connected to the SCB block to oversample input and output signals. You must use one of the 8-bit or 16-bit dividers <em><b>(the source clock of this divider must be Clk_Peri)</b></em>. Use the <a class="el" href="group__group__sysclk.html">System Clock (SysClk)</a> driver API to do that.</p>
<div class="fragment"><div class="line"><span class="comment">/* Assign divider type and number for EZI2C */</span></div><div class="line"><span class="preprocessor">#define EZI2C_CLK_DIV_TYPE  (CY_SYSCLK_DIV_8_BIT)</span></div><div class="line"><span class="preprocessor">#define EZI2C_CLK_DIV_NUM   (0UL)</span></div><div class="line"></div><div class="line"><span class="comment">/* Connect assigned divider to be a clock source for EZI2C */</span></div><div class="line"><a class="code" href="group__group__sysclk__clk__peripheral__funcs.html#gacb66324e3191006f6d1cee8b29238fb2">Cy_SysClk_PeriphAssignDivider</a>(PCLK_SCB3_CLOCK, EZI2C_CLK_DIV_TYPE, EZI2C_CLK_DIV_NUM);</div></div><!-- fragment --> <h2><a class="anchor" id="group_scb_ezi2c_data_rate"></a>
Configure Data Rate</h2>
<p>To get EZI2C slave to operate at the desired data rate, the source clock must be fast enough to provide sufficient oversampling. Therefore, the clock divider must be configured to provide desired clock frequency. Use the <a class="el" href="group__group__sysclk.html">System Clock (SysClk)</a> driver API to do that. Refer to the technical reference manual (TRM) section I2C sub-section Oversampling and Bit Rate to get information about how to configure the I2C to run at the desired data rate.</p>
<div class="fragment"><div class="line"><span class="comment">/* EZI2C slave desired data rate is 400 kbps.</span></div><div class="line"><span class="comment">* To support this data rate the clock frequency must be in range 6 – 16 MHz.</span></div><div class="line"><span class="comment">* For PeriClk = 50 MHz, select divider value 4 and get EZI2C clock = (50 MHz / 4) = 12.5MHz.</span></div><div class="line"><span class="comment">* This clock frequency meets requirements above.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><a class="code" href="group__group__sysclk__clk__peripheral__funcs.html#gac67931844e6ec06b5ff88f4f3119e127">Cy_SysClk_PeriphSetDivider</a>   (EZI2C_CLK_DIV_TYPE, EZI2C_CLK_DIV_NUM, 3u);</div><div class="line"><a class="code" href="group__group__sysclk__clk__peripheral__funcs.html#ga8c626f11b583d8296516bbcf4a22f98e">Cy_SysClk_PeriphEnableDivider</a>(EZI2C_CLK_DIV_TYPE, EZI2C_CLK_DIV_NUM);</div></div><!-- fragment --> <h2><a class="anchor" id="group_scb_ezi2c_intr"></a>
Configure Interrupt</h2>
<p>The interrupt is mandatory for the EZI2C slave operation. The <a class="el" href="group__group__scb__ezi2c__slave__functions.html#ga5e811e428ecb264dddb284066d6ff956">Cy_SCB_EZI2C_Interrupt</a> function must be called in the interrupt handler for the selected SCB instance. Also, this interrupt must be enabled in the NVIC or it will not work.</p>
<div class="fragment"><div class="line"><span class="comment">/* Implement ISR for EZI2C */</span></div><div class="line"><span class="keywordtype">void</span> EZI2C_Isr(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group__group__scb__ezi2c__slave__functions.html#ga5e811e428ecb264dddb284066d6ff956">Cy_SCB_EZI2C_Interrupt</a>(SCB3, &amp;ezI2cContext);</div><div class="line">}</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">/* Assign EZI2C interrupt number and priority */</span></div><div class="line"><span class="preprocessor">#define EZI2C_INTR_NUM        scb_3_interrupt_IRQn</span></div><div class="line"><span class="preprocessor">#define EZI2C_INTR_PRIORITY   (7UL)</span></div><div class="line"></div><div class="line"><span class="comment">/* Populate configuration structure (code specific for CM4) */</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="structcy__stc__sysint__t.html">cy_stc_sysint_t</a> ezI2cIntrConfig =</div><div class="line">{</div><div class="line">    .<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>      = EZI2C_INTR_NUM,</div><div class="line">    .intrPriority = EZI2C_INTR_PRIORITY,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* Hook interrupt service routine and enable interrupt */</span></div><div class="line">(void) <a class="code" href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d">Cy_SysInt_Init</a>(&amp;ezI2cIntrConfig, &amp;EZI2C_Isr);</div><div class="line">NVIC_EnableIRQ(EZI2C_INTR_NUM);</div></div><!-- fragment --> <h2><a class="anchor" id="group_scb_ezi2c_enable"></a>
Enable EZI2C slave</h2>
<p>Finally, enable the EZI2C slave operation by calling <a class="el" href="group__group__scb__ezi2c__general__functions.html#gae5c13ff7a89e0a75fbe83bd5dfc4fc95">Cy_SCB_EZI2C_Enable</a>. Now the I2C device responds to the assigned address. </p><div class="fragment"><div class="line"><span class="comment">/* Enable I2C to operate */</span></div><div class="line"><a class="code" href="group__group__scb__ezi2c__general__functions.html#gae5c13ff7a89e0a75fbe83bd5dfc4fc95">Cy_SCB_EZI2C_Enable</a>(SCB3);</div><div class="line"></div><div class="line"><span class="comment">/* Enable global interrupts */</span></div><div class="line">__enable_irq();</div></div><!-- fragment --> <h1><a class="anchor" id="group_scb_ezi2c_use_cases"></a>
Common Use Cases</h1>
<p>The EZI2C slave operation might not require calling any EZI2C slave function because the I2C master is able to access the slave buffer. The application can directly access it as well. Note that this is an application-level task to ensure the buffer content integrity.</p>
<h2><a class="anchor" id="group_scb_ezi2c_master_wr"></a>
Master Write operation</h2>
<p>This operation starts with sending a base address that is one or two bytes, depending on the sub-address size configuration. This base address is retained and will be used for later read operations. Following the base address, there is a sequence of bytes written into the buffer starting from the base address location. The buffer index is incremented for each written byte, but this does not affect the base address that is retained. The length of a write operation is limited by the maximum buffer read/write region size.<br />
When a master attempts to write outside the read/write region or past the end of the buffer, the last byte is NACKed.</p>
<div class="image">
<img src="scb_ezi2c_write.png" alt="scb_ezi2c_write.png"/>
</div>
<h2><a class="anchor" id="group_scb_ezi2c_master_rd"></a>
Master Read operation</h2>
<p>This operation always starts from the base address set by the most recent write operation. The buffer index is incremented for each read byte. Two sequential read operations start from the same base address no matter how many bytes are read. The length of a read operation is not limited by the maximum size of the data buffer. The EZI2C slave returns 0xFF bytes if the read operation passes the end of the buffer.<br />
Typically, a read operation requires the base address to be updated before starting the read. In this case, the write and read operations must be combined together.</p>
<div class="image">
<img src="scb_ezi2c_read.png" alt="scb_ezi2c_read.png"/>
</div>
<p>The I2C master may use the ReStart or Stop/Start conditions to combine the operations. The write operation sets only the base address and the following read operation will start from the new base address. In cases where the base address remains the same, there is no need for a write operation. </p><div class="image">
<img src="scb_ezi2c_set_ba_read.png" alt="scb_ezi2c_set_ba_read.png"/>
</div>
<h1><a class="anchor" id="group_scb_ezi2c_lp"></a>
Low Power Support</h1>
<p>The EZI2C slave provides the callback functions to handle power mode transition. The callback <a class="el" href="group__group__scb__ezi2c__low__power__functions.html#ga7850f09755b5713829be8d793424c64a">Cy_SCB_EZI2C_DeepSleepCallback</a> must be called during execution of <a class="el" href="group__group__syspm__functions__power.html#ga1211c6447be4863cb7ca807e2c9f98ee">Cy_SysPm_DeepSleep</a>; <a class="el" href="group__group__scb__ezi2c__low__power__functions.html#ga2eb1ccb1d6bd2ff7439aadb206c4d3a8">Cy_SCB_EZI2C_HibernateCallback</a> must be called during execution of <a class="el" href="group__group__syspm__functions__power.html#ga2929e98b966d58c9246108a767ed7f53">Cy_SysPm_Hibernate</a>. To trigger the callback execution, the callback must be registered before calling the power mode transition function. Refer to <a class="el" href="group__group__syspm.html">System Power Management (SysPm)</a> driver for more information about power mode transitions and callback registration.</p>
<dl class="section note"><dt>Note</dt><dd>Only applicable for <b>rev-08 of the CY8CKIT-062-BLE</b>. For proper operation, when the EZI2C slave is configured to be a wakeup source from Deep Sleep mode, the <a class="el" href="group__group__scb__ezi2c__low__power__functions.html#ga7850f09755b5713829be8d793424c64a">Cy_SCB_EZI2C_DeepSleepCallback</a> must be copied and modified. Refer to the function description to get the details.</dd></dl>
<h1><a class="anchor" id="group_scb_ezi2c_more_information"></a>
More Information</h1>
<p>For more information on the SCB peripheral, refer to the technical reference manual (TRM).</p>
<h1><a class="anchor" id="group_scb_ezi2c_MISRA"></a>
MISRA-C Compliance</h1>
<table class="doxtable">
<tr>
<th>MISRA Rule </th><th>Rule Class (Required/Advisory) </th><th>Rule Description </th><th>Description of Deviation(s)  </th></tr>
<tr>
<td>11.4 </td><td>A </td><td>A cast should not be performed between a pointer to object type and a different pointer to object type. </td><td>The functions <a class="el" href="group__group__scb__ezi2c__low__power__functions.html#ga7850f09755b5713829be8d793424c64a">Cy_SCB_EZI2C_DeepSleepCallback</a> and <a class="el" href="group__group__scb__ezi2c__low__power__functions.html#ga2eb1ccb1d6bd2ff7439aadb206c4d3a8">Cy_SCB_EZI2C_HibernateCallback</a> are callback of <a class="el" href="group__group__syspm__data__enumerates.html#ga601b1cb722cb091133caf33d8ab235ca">cy_en_syspm_status_t</a> type. The cast operation safety in these functions becomes the user's responsibility because pointers are initialized when callback is registered in SysPm driver.  </td></tr>
<tr>
<td>14.1 </td><td>R </td><td>There shall be no unreachable code. </td><td>The SCB block parameters can be a constant false or true depending on the selected device and cause code to be unreachable.  </td></tr>
<tr>
<td>14.2 </td><td>R </td><td>All non-null statements shall either: a) have at least one side-effect however executed, or b) cause control flow to change. </td><td>The unused function parameters are cast to void. This statement has no side-effect and is used to suppress a compiler warning.  </td></tr>
<tr>
<td>14.7 </td><td>R </td><td>A function shall have a single point of exit at the end of the function. </td><td>The functions can return from several points. This is done to improve code clarity when returning error status code if input parameter validation fails.  </td></tr>
</table>
<h1><a class="anchor" id="group_scb_ezi2c_changelog"></a>
Changelog</h1>
<table class="doxtable">
<tr>
<th>Version</th><th>Changes</th><th>Reason for Change </th></tr>
<tr>
<td>2.10 </td><td>None. </td><td>SCB I2C driver updated.  </td></tr>
<tr>
<td rowspan="2">2.0 </td><td>Added parameters validation for public API. </td><td></td></tr>
<tr>
<td>Replaced variables that have limited range of values with enumerated types. </td><td></td></tr>
<tr>
<td>1.0 </td><td>Initial version. </td><td></td></tr>
</table>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
API Reference</h2></td></tr>
<tr class="memitem:group__group__scb__ezi2c__macros"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__ezi2c__macros.html">Macros</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__scb__ezi2c__functions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__ezi2c__functions.html">Functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__scb__ezi2c__data__structures"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__ezi2c__data__structures.html">Data Structures</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__scb__ezi2c__enums"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__ezi2c__enums.html">Enumerated Types</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>Cypress Peripheral Driver Library (PDL)</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
