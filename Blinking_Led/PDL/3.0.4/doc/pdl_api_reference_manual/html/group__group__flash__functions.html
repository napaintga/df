<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cypress Peripheral Driver Library (PDL): Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="cypress_logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Cypress Peripheral Driver Library (PDL)
   &#160;<span id="projectnumber">Version 3.0.4.57</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__flash__functions.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Functions<div class="ingroups"><a class="el" href="group__group__flash.html">Flash System Routine (Flash)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf1b44a029169a1baa08e211bff714a19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#gaf1b44a029169a1baa08e211bff714a19">Cy_Flash_Init</a> (void)</td></tr>
<tr class="memdesc:gaf1b44a029169a1baa08e211bff714a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates all needed prerequisites to support flash erase/write.  <a href="#gaf1b44a029169a1baa08e211bff714a19">More...</a><br /></td></tr>
<tr class="separator:gaf1b44a029169a1baa08e211bff714a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b9753a9fca6ebea833cbc4af7f0d681"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#ga6b9753a9fca6ebea833cbc4af7f0d681">Cy_Flash_EraseRow</a> (uint32_t rowAddr)</td></tr>
<tr class="memdesc:ga6b9753a9fca6ebea833cbc4af7f0d681"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function erases a single row of flash.  <a href="#ga6b9753a9fca6ebea833cbc4af7f0d681">More...</a><br /></td></tr>
<tr class="separator:ga6b9753a9fca6ebea833cbc4af7f0d681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5218274c43e64791cf28f902d15a355a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#ga5218274c43e64791cf28f902d15a355a">Cy_Flash_ProgramRow</a> (uint32_t rowAddr, const uint32_t *data)</td></tr>
<tr class="memdesc:ga5218274c43e64791cf28f902d15a355a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes an array of data to a single row of flash.  <a href="#ga5218274c43e64791cf28f902d15a355a">More...</a><br /></td></tr>
<tr class="separator:ga5218274c43e64791cf28f902d15a355a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafaa220a63444c4e5a5abe9b8c2cec721"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#gafaa220a63444c4e5a5abe9b8c2cec721">Cy_Flash_WriteRow</a> (uint32_t rowAddr, const uint32_t *data)</td></tr>
<tr class="memdesc:gafaa220a63444c4e5a5abe9b8c2cec721"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes an array of data to a single row of flash.  <a href="#gafaa220a63444c4e5a5abe9b8c2cec721">More...</a><br /></td></tr>
<tr class="separator:gafaa220a63444c4e5a5abe9b8c2cec721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafed287628c010c2258f73c5777b52292"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#gafed287628c010c2258f73c5777b52292">Cy_Flash_StartWrite</a> (uint32_t rowAddr, const uint32_t *data)</td></tr>
<tr class="memdesc:gafed287628c010c2258f73c5777b52292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs pre-program, erase and then starts programming the flash row with the input data.  <a href="#gafed287628c010c2258f73c5777b52292">More...</a><br /></td></tr>
<tr class="separator:gafed287628c010c2258f73c5777b52292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc57348bb2e6922a65826bccad961fed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#gafc57348bb2e6922a65826bccad961fed">Cy_Flash_StartProgram</a> (uint32_t rowAddr, const uint32_t *data)</td></tr>
<tr class="memdesc:gafc57348bb2e6922a65826bccad961fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts writing an array of data to a single row of flash.  <a href="#gafc57348bb2e6922a65826bccad961fed">More...</a><br /></td></tr>
<tr class="separator:gafc57348bb2e6922a65826bccad961fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99332e54ebdbf6414cad93ad72db1fb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#ga99332e54ebdbf6414cad93ad72db1fb2">Cy_Flash_StartErase</a> (uint32_t rowAddr)</td></tr>
<tr class="memdesc:ga99332e54ebdbf6414cad93ad72db1fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts erasing a single row of flash.  <a href="#ga99332e54ebdbf6414cad93ad72db1fb2">More...</a><br /></td></tr>
<tr class="separator:ga99332e54ebdbf6414cad93ad72db1fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga436020eae198750c56b93dbabdf6dc6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#ga436020eae198750c56b93dbabdf6dc6d">Cy_Flash_IsOperationComplete</a> (void)</td></tr>
<tr class="memdesc:ga436020eae198750c56b93dbabdf6dc6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports a successful operation result, reason of failure or busy status ( <a class="el" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a9ddac0d7038bbdfe57db1acbeac9df82">CY_FLASH_DRV_OPCODE_BUSY</a> ).  <a href="#ga436020eae198750c56b93dbabdf6dc6d">More...</a><br /></td></tr>
<tr class="separator:ga436020eae198750c56b93dbabdf6dc6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29ac711091186d8a7790be298fb6148b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#ga29ac711091186d8a7790be298fb6148b">Cy_Flash_RowChecksum</a> (uint32_t rowAddr, uint32_t *checksumPtr)</td></tr>
<tr class="memdesc:ga29ac711091186d8a7790be298fb6148b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a checksum value of the specified flash row.  <a href="#ga29ac711091186d8a7790be298fb6148b">More...</a><br /></td></tr>
<tr class="separator:ga29ac711091186d8a7790be298fb6148b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f948f4d096b9f93488a889a011bda14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#ga3f948f4d096b9f93488a889a011bda14">Cy_Flash_CalculateHash</a> (const uint32_t *data, uint32_t numberOfBytes, uint32_t *hashPtr)</td></tr>
<tr class="memdesc:ga3f948f4d096b9f93488a889a011bda14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a hash value of the specified region of flash.  <a href="#ga3f948f4d096b9f93488a889a011bda14">More...</a><br /></td></tr>
<tr class="separator:ga3f948f4d096b9f93488a889a011bda14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga607931427f2d4a2147c7c97ce96577e0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#ga607931427f2d4a2147c7c97ce96577e0">Cy_Flash_GetExternalStatus</a> (void)</td></tr>
<tr class="memdesc:ga607931427f2d4a2147c7c97ce96577e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles the case where a module such as security image captures a system call from this driver and reports its own status or error code, for example protection violation.  <a href="#ga607931427f2d4a2147c7c97ce96577e0">More...</a><br /></td></tr>
<tr class="separator:ga607931427f2d4a2147c7c97ce96577e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf1b44a029169a1baa08e211bff714a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1b44a029169a1baa08e211bff714a19">&#9670;&nbsp;</a></span>Cy_Flash_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_Flash_Init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates all needed prerequisites to support flash erase/write. </p>
<p>Should be called from each core.</p>
<p>Requires a call to Cy_IPC_SystemSemaInit() and Cy_IPC_SystemPipeInit() functions before use.</p>
<p>This function is called in the <a class="el" href="group__group__system__config__system__functions.html#ga93f514700ccf00d08dbdcff7f1224eb2" title="Initializes the system: ">SystemInit()</a> function, for proper flash write and erase operations. If the default startup file is not used, or the function <a class="el" href="group__group__system__config__system__functions.html#ga93f514700ccf00d08dbdcff7f1224eb2" title="Initializes the system: ">SystemInit()</a> is not called in your project, call the following three functions prior to executing any flash or EmEEPROM write or erase operations:</p><ol type="1">
<li>Cy_IPC_SystemSemaInit()</li>
<li>Cy_IPC_SystemPipeInit()</li>
<li><a class="el" href="group__group__flash__functions.html#gaf1b44a029169a1baa08e211bff714a19" title="Initiates all needed prerequisites to support flash erase/write. ">Cy_Flash_Init()</a> </li>
</ol>

</div>
</div>
<a id="ga6b9753a9fca6ebea833cbc4af7f0d681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b9753a9fca6ebea833cbc4af7f0d681">&#9670;&nbsp;</a></span>Cy_Flash_EraseRow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> Cy_Flash_EraseRow </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rowAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function erases a single row of flash. </p>
<p>Reports success or a reason for failure. Does not return until the Write operation is complete. Returns immediately and reports a <a class="el" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a6b2c46694345a4366933c0a7dfbec4ae">CY_FLASH_DRV_IPC_BUSY</a> error in the case when another process is writing to flash or erasing the row. User firmware should not enter the Hibernate or Deep-Sleep mode until flash Erase is complete. The Flash operation is allowed in Sleep mode. During the Flash operation, the device should not be reset, including the XRES pin, a software reset, and watchdog reset sources. Also, low-voltage detect circuits should be configured to generate an interrupt instead of a reset. Otherwise, portions of flash may undergo unexpected changes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowAddr</td><td>Address of the flash row number. The number of the flash rows is defined by the <a class="el" href="group__group__flash__general__macros.html#ga72919a89e4ca9c70f685c8854aa7685d">CY_FLASH_NUMBER_ROWS</a> macro for the selected device. The Read-while-Write violation occurs when the flash read operation is initiated in the same flash sector where the flash write operation is performing. Refer to the device datasheet for the details. Address must match row start address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the Flash operation, see <a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>. </dd></dl>

</div>
</div>
<a id="ga5218274c43e64791cf28f902d15a355a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5218274c43e64791cf28f902d15a355a">&#9670;&nbsp;</a></span>Cy_Flash_ProgramRow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> Cy_Flash_ProgramRow </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rowAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes an array of data to a single row of flash. </p>
<p>Reports success or a reason for failure. Does not return until the Program operation is complete. Returns immediately and reports a <a class="el" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a6b2c46694345a4366933c0a7dfbec4ae">CY_FLASH_DRV_IPC_BUSY</a> error in the case when another process is writing to flash. User firmware should not enter the Hibernate or Deep-sleep mode until flash Write is complete. The Flash operation is allowed in Sleep mode. During the Flash operation, the device should not be reset, including the XRES pin, a software reset, and watchdog reset sources. Also, low-voltage detect circuits should be configured to generate an interrupt instead of a reset. Otherwise, portions of flash may undergo unexpected changes.<br />
Before calling this function, the target flash region must be erased by the StartErase/EraseRow function.<br />
Data to be programmed must be located in the SRAM memory region. </p><dl class="section note"><dt>Note</dt><dd>Before reading data from previously programmed/erased flash rows, the user must clear the flash cache with the <a class="el" href="group__group__syslib__functions.html#ga1691f4df41994e7ed9c30ec6495d925f" title="This function invalidates the flash cache and buffer. ">Cy_SysLib_ClearFlashCacheAndBuffer()</a> function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowAddr</td><td>Address of the flash row number. The number of the flash rows is defined by the <a class="el" href="group__group__flash__general__macros.html#ga72919a89e4ca9c70f685c8854aa7685d">CY_FLASH_NUMBER_ROWS</a> macro for the selected device. The Read-while-Write violation occurs when the flash read operation is initiated in the same flash sector where the flash write operation is performing. Refer to the device datasheet for the details. Address must match row start address.</td></tr>
    <tr><td class="paramname">data</td><td>The pointer to the data which has to be written to flash. The size of the data array must be equal to the flash row size. The flash row size for the selected device is defined by the <a class="el" href="group__group__flash__general__macros.html#ga407c9c16fafa7275c911133eaf8563a4">CY_FLASH_SIZEOF_ROW</a> macro. Refer to the device datasheet for the details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the Flash operation, see <a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>. </dd></dl>

</div>
</div>
<a id="gafaa220a63444c4e5a5abe9b8c2cec721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafaa220a63444c4e5a5abe9b8c2cec721">&#9670;&nbsp;</a></span>Cy_Flash_WriteRow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> Cy_Flash_WriteRow </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rowAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes an array of data to a single row of flash. </p>
<p>This is done in three steps - pre-program, erase and then program flash row with the input data. Reports success or a reason for failure. Does not return until the Write operation is complete. Returns immediately and reports a <a class="el" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a6b2c46694345a4366933c0a7dfbec4ae">CY_FLASH_DRV_IPC_BUSY</a> error in the case when another process is writing to flash. User firmware should not enter the Hibernate or Deep-sleep mode until flash Write is complete. The Flash operation is allowed in Sleep mode. During the Flash operation, the device should not be reset, including the XRES pin, a software reset, and watchdog reset sources. Also, low-voltage detect circuits should be configured to generate an interrupt instead of a reset. Otherwise, portions of flash may undergo unexpected changes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowAddr</td><td>Address of the flash row number. The number of the flash rows is defined by the <a class="el" href="group__group__flash__general__macros.html#ga72919a89e4ca9c70f685c8854aa7685d">CY_FLASH_NUMBER_ROWS</a> macro for the selected device. The Read-while-Write violation occurs when the flash read operation is initiated in the same flash sector where the flash write operation is performing. Refer to the device datasheet for the details. Address must match row start address.</td></tr>
    <tr><td class="paramname">data</td><td>The pointer to the data which has to be written to flash. The size of the data array must be equal to the flash row size. The flash row size for the selected device is defined by the <a class="el" href="group__group__flash__general__macros.html#ga407c9c16fafa7275c911133eaf8563a4">CY_FLASH_SIZEOF_ROW</a> macro. Refer to the device datasheet for the details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the Flash operation, see <a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>. </dd></dl>

</div>
</div>
<a id="gafed287628c010c2258f73c5777b52292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafed287628c010c2258f73c5777b52292">&#9670;&nbsp;</a></span>Cy_Flash_StartWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> Cy_Flash_StartWrite </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rowAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs pre-program, erase and then starts programming the flash row with the input data. </p>
<p>Returns immediately and reports a successful start or reason for failure. Reports a <a class="el" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a6b2c46694345a4366933c0a7dfbec4ae">CY_FLASH_DRV_IPC_BUSY</a> error in the case when another process is writing to flash. User firmware should not enter the Hibernate or Deep-Sleep mode until flash Write is complete. The Flash operation is allowed in Sleep mode. During the flash operation, the device should not be reset, including the XRES pin, a software reset, and watchdog reset sources. Also, the low-voltage detect circuits should be configured to generate an interrupt instead of a reset. Otherwise, portions of flash may undergo unexpected changes. </p><dl class="section note"><dt>Note</dt><dd>Before reading data from previously programmed/erased flash rows, the user must clear the flash cache with the <a class="el" href="group__group__syslib__functions.html#ga1691f4df41994e7ed9c30ec6495d925f" title="This function invalidates the flash cache and buffer. ">Cy_SysLib_ClearFlashCacheAndBuffer()</a> function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowAddr</td><td>Address of the flash row number. The number of the flash rows is defined by the <a class="el" href="group__group__flash__general__macros.html#ga72919a89e4ca9c70f685c8854aa7685d">CY_FLASH_NUMBER_ROWS</a> macro for the selected device. The Read-while-Write violation occurs when the flash read operation is initiated in the same flash sector where the flash write operation is performing. Refer to the device datasheet for the details. Address must match row start address.</td></tr>
    <tr><td class="paramname">data</td><td>The pointer to the data to be written to flash. The size of the data array must be equal to the flash row size. The flash row size for the selected device is defined by the <a class="el" href="group__group__flash__general__macros.html#ga407c9c16fafa7275c911133eaf8563a4">CY_FLASH_SIZEOF_ROW</a> macro. Refer to the device datasheet for the details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the Flash operation, see <a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>. </dd></dl>

</div>
</div>
<a id="gafc57348bb2e6922a65826bccad961fed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc57348bb2e6922a65826bccad961fed">&#9670;&nbsp;</a></span>Cy_Flash_StartProgram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> Cy_Flash_StartProgram </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rowAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts writing an array of data to a single row of flash. </p>
<p>Returns immediately and reports a successful start or reason for failure. Reports a <a class="el" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a6b2c46694345a4366933c0a7dfbec4ae">CY_FLASH_DRV_IPC_BUSY</a> error if another process is writing to flash. The user firmware should not enter Hibernate or Deep-Sleep mode until flash Program is complete. The Flash operation is allowed in Sleep mode. During the Flash operation, the device should not be reset, including the XRES pin, a software reset, and watchdog reset sources. Also, the low-voltage detect circuits should be configured to generate an interrupt instead of a reset. Otherwise, portions of flash may undergo unexpected changes.<br />
Before calling this function, the target flash region must be erased by the StartErase/EraseRow function.<br />
Data to be programmed must be located in the SRAM memory region. </p><dl class="section note"><dt>Note</dt><dd>Before reading data from previously programmed/erased flash rows, the user must clear the flash cache with the <a class="el" href="group__group__syslib__functions.html#ga1691f4df41994e7ed9c30ec6495d925f" title="This function invalidates the flash cache and buffer. ">Cy_SysLib_ClearFlashCacheAndBuffer()</a> function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowAddr</td><td>The address of the flash row number. The number of the flash rows is defined by the <a class="el" href="group__group__flash__general__macros.html#ga72919a89e4ca9c70f685c8854aa7685d">CY_FLASH_NUMBER_ROWS</a> macro for the selected device. The Read-while-Write violation occurs when the Flash Write operation is performing. Refer to the device datasheet for the details. The address must match the row start address.</td></tr>
    <tr><td class="paramname">data</td><td>The pointer to the data to be written to flash. The size of the data array must be equal to the flash row size. The flash row size for the selected device is defined by the <a class="el" href="group__group__flash__general__macros.html#ga407c9c16fafa7275c911133eaf8563a4">CY_FLASH_SIZEOF_ROW</a> macro. Refer to the device datasheet for the details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the Flash operation, see <a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>. </dd></dl>

</div>
</div>
<a id="ga99332e54ebdbf6414cad93ad72db1fb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99332e54ebdbf6414cad93ad72db1fb2">&#9670;&nbsp;</a></span>Cy_Flash_StartErase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> Cy_Flash_StartErase </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rowAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts erasing a single row of flash. </p>
<p>Returns immediately and reports a successful start or reason for failure. Reports a <a class="el" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a6b2c46694345a4366933c0a7dfbec4ae">CY_FLASH_DRV_IPC_BUSY</a> error in the case when IPC structure is locked by another process. User firmware should not enter the Hibernate or Deep-Sleep mode until flash Erase is complete. The Flash operation is allowed in Sleep mode. During the flash operation, the device should not be reset, including the XRES pin, a software reset, and watchdog reset sources. Also, the low-voltage detect circuits should be configured to generate an interrupt instead of a reset. Otherwise, portions of flash may undergo unexpected changes. </p><dl class="section note"><dt>Note</dt><dd>Before reading data from previously programmed/erased flash rows, the user must clear the flash cache with the <a class="el" href="group__group__syslib__functions.html#ga1691f4df41994e7ed9c30ec6495d925f" title="This function invalidates the flash cache and buffer. ">Cy_SysLib_ClearFlashCacheAndBuffer()</a> function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowAddr</td><td>Address of the flash row number. The number of the flash rows is defined by the <a class="el" href="group__group__flash__general__macros.html#ga72919a89e4ca9c70f685c8854aa7685d">CY_FLASH_NUMBER_ROWS</a> macro for the selected device. The Read-while-Write violation occurs when the flash read operation is initiated in the same flash sector where the flash erase operation is performing. Refer to the device datasheet for the details. Address must match row start address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the Flash operation, see <a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>. </dd></dl>

</div>
</div>
<a id="ga436020eae198750c56b93dbabdf6dc6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga436020eae198750c56b93dbabdf6dc6d">&#9670;&nbsp;</a></span>Cy_Flash_IsOperationComplete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> Cy_Flash_IsOperationComplete </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports a successful operation result, reason of failure or busy status ( <a class="el" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a9ddac0d7038bbdfe57db1acbeac9df82">CY_FLASH_DRV_OPCODE_BUSY</a> ). </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the Flash operation (see <a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>). </dd></dl>

</div>
</div>
<a id="ga29ac711091186d8a7790be298fb6148b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29ac711091186d8a7790be298fb6148b">&#9670;&nbsp;</a></span>Cy_Flash_RowChecksum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> Cy_Flash_RowChecksum </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rowAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>checksumPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a checksum value of the specified flash row. </p>
<dl class="section note"><dt>Note</dt><dd>Now <a class="el" href="group__group__flash__functions.html#ga29ac711091186d8a7790be298fb6148b" title="Returns a checksum value of the specified flash row. ">Cy_Flash_RowChecksum()</a> requires the row <b>address</b> (rowAddr) as a parameter. In previous versions of the driver, this function used the row <b>number</b> (rowNum) for this parameter.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowAddr</td><td>The address of the flash row.</td></tr>
    <tr><td class="paramname">checksumPtr</td><td>The pointer to the address where checksum is to be stored</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the Flash operation. </dd></dl>

</div>
</div>
<a id="ga3f948f4d096b9f93488a889a011bda14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f948f4d096b9f93488a889a011bda14">&#9670;&nbsp;</a></span>Cy_Flash_CalculateHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> Cy_Flash_CalculateHash </td>
          <td>(</td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numberOfBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>hashPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a hash value of the specified region of flash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Start the data address.</td></tr>
    <tr><td class="paramname">numberOfBytes</td><td>The hash value is calculated for the number of bytes after the start data address (0 - 1 byte, 1- 2 bytes etc).</td></tr>
    <tr><td class="paramname">hashPtr</td><td>The pointer to the address where hash is to be stored</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the Flash operation. </dd></dl>

</div>
</div>
<a id="ga607931427f2d4a2147c7c97ce96577e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga607931427f2d4a2147c7c97ce96577e0">&#9670;&nbsp;</a></span>Cy_Flash_GetExternalStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_Flash_GetExternalStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles the case where a module such as security image captures a system call from this driver and reports its own status or error code, for example protection violation. </p>
<p>In that case, a function from this driver returns an unknown error (see <a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>). After receipt of an unknown error, the user may call this function to get the status of the capturing module.</p>
<p>The user is responsible for parsing the content of the returned value and casting it to the appropriate enumeration.</p>
<dl class="section return"><dt>Returns</dt><dd>The error code that was stored in the opcode variable. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>Cypress Peripheral Driver Library (PDL)</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
