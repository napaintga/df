<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cypress Peripheral Driver Library (PDL): Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="cypress_logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Cypress Peripheral Driver Library (PDL)
   &#160;<span id="projectnumber">Version 3.0.4.57</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__sysint__functions.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Functions<div class="ingroups"><a class="el" href="group__group__sysint.html">System Interrupt (SysInt)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga0eaacabcabf1a881b93f3eb20f6b406c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__functions.html#ga0eaacabcabf1a881b93f3eb20f6b406c">Cy_SysInt_GetState</a>&#160;&#160;&#160;NVIC_GetEnableIRQ</td></tr>
<tr class="memdesc:ga0eaacabcabf1a881b93f3eb20f6b406c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is deprecated.  <a href="#ga0eaacabcabf1a881b93f3eb20f6b406c">More...</a><br /></td></tr>
<tr class="separator:ga0eaacabcabf1a881b93f3eb20f6b406c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab2ff6820a898e9af3f780000054eea5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__sysint__enums.html#ga01619b224f9d5c23915e51783ea184c8">cy_en_sysint_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d">Cy_SysInt_Init</a> (const <a class="el" href="structcy__stc__sysint__t.html">cy_stc_sysint_t</a> *config, <a class="el" href="group__group__syslib__macros.html#ga71c09beda7671d1f69c8f06a546e2ae6">cy_israddress</a> userIsr)</td></tr>
<tr class="memdesc:gab2ff6820a898e9af3f780000054eea5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the referenced interrupt by setting the priority and the interrupt vector.  <a href="#gab2ff6820a898e9af3f780000054eea5d">More...</a><br /></td></tr>
<tr class="separator:gab2ff6820a898e9af3f780000054eea5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e5145f89effd2cd5950522748931b32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__syslib__macros.html#ga71c09beda7671d1f69c8f06a546e2ae6">cy_israddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__functions.html#ga7e5145f89effd2cd5950522748931b32">Cy_SysInt_SetVector</a> (<a class="el" href="struct_i_r_qn___type.html">IRQn_Type</a> intrSrc, <a class="el" href="group__group__syslib__macros.html#ga71c09beda7671d1f69c8f06a546e2ae6">cy_israddress</a> userIsr)</td></tr>
<tr class="memdesc:ga7e5145f89effd2cd5950522748931b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the ISR vector for the Interrupt.  <a href="#ga7e5145f89effd2cd5950522748931b32">More...</a><br /></td></tr>
<tr class="separator:ga7e5145f89effd2cd5950522748931b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa56f1672161e6725ae8c0a17f57a8277"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__syslib__macros.html#ga71c09beda7671d1f69c8f06a546e2ae6">cy_israddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__functions.html#gaa56f1672161e6725ae8c0a17f57a8277">Cy_SysInt_GetVector</a> (<a class="el" href="struct_i_r_qn___type.html">IRQn_Type</a> intrSrc)</td></tr>
<tr class="memdesc:gaa56f1672161e6725ae8c0a17f57a8277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the address of the current ISR vector for the Interrupt.  <a href="#gaa56f1672161e6725ae8c0a17f57a8277">More...</a><br /></td></tr>
<tr class="separator:gaa56f1672161e6725ae8c0a17f57a8277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad11800befe8f66ff0c953e335cb172bb"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__functions.html#gad11800befe8f66ff0c953e335cb172bb">Cy_SysInt_SetIntSourceNMI</a> (<a class="el" href="struct_i_r_qn___type.html">IRQn_Type</a> intrSrc)</td></tr>
<tr class="memdesc:gad11800befe8f66ff0c953e335cb172bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the interrupt source of NMI.  <a href="#gad11800befe8f66ff0c953e335cb172bb">More...</a><br /></td></tr>
<tr class="separator:gad11800befe8f66ff0c953e335cb172bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34e083287947309c6c1e4ace72b911da"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="struct_i_r_qn___type.html">IRQn_Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__functions.html#ga34e083287947309c6c1e4ace72b911da">Cy_SysInt_GetIntSourceNMI</a> (void)</td></tr>
<tr class="memdesc:ga34e083287947309c6c1e4ace72b911da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the interrupt source of the NMI.  <a href="#ga34e083287947309c6c1e4ace72b911da">More...</a><br /></td></tr>
<tr class="separator:ga34e083287947309c6c1e4ace72b911da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86bb2a7b42f6706f5da5a55b7cb42022"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__functions.html#ga86bb2a7b42f6706f5da5a55b7cb42022">Cy_SysInt_SetIntSource</a> (<a class="el" href="struct_i_r_qn___type.html">IRQn_Type</a> intrSrc, <a class="el" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a> cm0pSrc)</td></tr>
<tr class="memdesc:ga86bb2a7b42f6706f5da5a55b7cb42022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the interrupt mux for the specified CM0+ NVIC channel.  <a href="#ga86bb2a7b42f6706f5da5a55b7cb42022">More...</a><br /></td></tr>
<tr class="separator:ga86bb2a7b42f6706f5da5a55b7cb42022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82557e0d5a9cbd68677f58afbc19db55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__functions.html#ga82557e0d5a9cbd68677f58afbc19db55">Cy_SysInt_GetIntSource</a> (<a class="el" href="struct_i_r_qn___type.html">IRQn_Type</a> intrSrc)</td></tr>
<tr class="memdesc:ga82557e0d5a9cbd68677f58afbc19db55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the interrupt source of CM0+ NVIC channel.  <a href="#ga82557e0d5a9cbd68677f58afbc19db55">More...</a><br /></td></tr>
<tr class="separator:ga82557e0d5a9cbd68677f58afbc19db55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6b70fb2e54d2bf2453ce20acd0a11b9"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__functions.html#gab6b70fb2e54d2bf2453ce20acd0a11b9">Cy_SysInt_SoftwareTrig</a> (<a class="el" href="struct_i_r_qn___type.html">IRQn_Type</a> intrSrc)</td></tr>
<tr class="memdesc:gab6b70fb2e54d2bf2453ce20acd0a11b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triggers an interrupt using software (Not applicable for CM0+).  <a href="#gab6b70fb2e54d2bf2453ce20acd0a11b9">More...</a><br /></td></tr>
<tr class="separator:gab6b70fb2e54d2bf2453ce20acd0a11b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga0eaacabcabf1a881b93f3eb20f6b406c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0eaacabcabf1a881b93f3eb20f6b406c">&#9670;&nbsp;</a></span>Cy_SysInt_GetState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Cy_SysInt_GetState&#160;&#160;&#160;NVIC_GetEnableIRQ</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is deprecated. </p>
<p>It invokes the NVIC_GetEnableIRQ function. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab2ff6820a898e9af3f780000054eea5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2ff6820a898e9af3f780000054eea5d">&#9670;&nbsp;</a></span>Cy_SysInt_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__sysint__enums.html#ga01619b224f9d5c23915e51783ea184c8">cy_en_sysint_status_t</a> Cy_SysInt_Init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcy__stc__sysint__t.html">cy_stc_sysint_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__syslib__macros.html#ga71c09beda7671d1f69c8f06a546e2ae6">cy_israddress</a>&#160;</td>
          <td class="paramname"><em>userIsr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the referenced interrupt by setting the priority and the interrupt vector. </p>
<p>Note that the interrupt vector will only be relocated if the vector table was moved to __ramVectors in SRAM. Otherwise it is ignored.</p>
<p>Use the CMSIS core function NVIC_EnableIRQ(config.intrSrc) to enable the interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>Interrupt configuration structure</td></tr>
    <tr><td class="paramname">userIsr</td><td>Address of the ISR</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Initialization status</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Vector table is relocated to RAM in __ramVectors[] */</span></div><div class="line">    </div><div class="line">    <span class="comment">/* Prototype of ISR function for port interrupt 0 */</span></div><div class="line">    <span class="keywordtype">void</span> Interrupt_Handler_Port0 (<span class="keywordtype">void</span>);</div><div class="line">    </div><div class="line">    <a class="code" href="structcy__stc__sysint__t.html">cy_stc_sysint_t</a> intrCfg =</div><div class="line">    {</div><div class="line"><span class="preprocessor">        #if (CY_CPU_CORTEX_M0P)</span></div><div class="line">            <span class="comment">/*.intrSrc =*/</span> NvicMux7_IRQn,               <span class="comment">/* CM0+ interrupt is NVIC #7 */</span></div><div class="line">            <span class="comment">/*.cm0pSrc =*/</span> ioss_interrupts_gpio_0_IRQn, <span class="comment">/* Source of NVIC #7 is GPIO port 0 interrupt */</span></div><div class="line">            <span class="comment">/*.intrPriority =*/</span> 2UL                     <span class="comment">/* Interrupt priority is 2 */</span></div><div class="line"><span class="preprocessor">        #else</span></div><div class="line">            <span class="comment">/*.intrSrc =*/</span> ioss_interrupts_gpio_0_IRQn, <span class="comment">/* Interrupt source is GPIO port 0 interrupt */</span></div><div class="line">            <span class="comment">/*.intrPriority =*/</span> 2UL                     <span class="comment">/* Interrupt priority is 2 */</span></div><div class="line"><span class="preprocessor">        #endif</span></div><div class="line">    };</div><div class="line">    </div><div class="line">    <span class="comment">/* Initialize the interrupt with vector at Interrupt_Handler_Port0() */</span></div><div class="line">    <a class="code" href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d">Cy_SysInt_Init</a>(&amp;intrCfg, &amp;Interrupt_Handler_Port0);</div><div class="line">    </div><div class="line">    <span class="comment">/* Enable the interrupt */</span></div><div class="line">    NVIC_EnableIRQ(intrCfg.<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>);</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga7e5145f89effd2cd5950522748931b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e5145f89effd2cd5950522748931b32">&#9670;&nbsp;</a></span>Cy_SysInt_SetVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__syslib__macros.html#ga71c09beda7671d1f69c8f06a546e2ae6">cy_israddress</a> Cy_SysInt_SetVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i_r_qn___type.html">IRQn_Type</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__syslib__macros.html#ga71c09beda7671d1f69c8f06a546e2ae6">cy_israddress</a>&#160;</td>
          <td class="paramname"><em>userIsr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the ISR vector for the Interrupt. </p>
<p>Note that for CM0+, this function sets the interrupt vector for the interrupt mux output feeding into the NVIC.</p>
<p>Note that this function relies on the assumption that the vector table is relocated to __ramVectors[RAM_VECTORS_SIZE] in SRAM. Otherwise it will return the address of the default ISR location in Flash vector table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intrSrc</td><td>Interrrupt source</td></tr>
    <tr><td class="paramname">userIsr</td><td>Address of the ISR to set in the interrupt vector table</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Previous address of the ISR in the interrupt vector table, before the function call</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Vector table is relocated to RAM in __ramVectors[]. The interrupt</span></div><div class="line"><span class="comment">                 was initialized with the &quot;intrCfg&quot; configuration struct. */</span></div><div class="line">    </div><div class="line">    <span class="comment">/* Prototype of ISR function for port interrupt 0 */</span></div><div class="line">    <span class="keywordtype">void</span> Interrupt_Handler_Port0 (<span class="keywordtype">void</span>);</div><div class="line">    </div><div class="line">    <span class="keywordflow">if</span>(&amp;Interrupt_Handler_Port0 != <a class="code" href="group__group__sysint__functions.html#gaa56f1672161e6725ae8c0a17f57a8277">Cy_SysInt_GetVector</a>(intrCfg.<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Set the port0 interrupt vector to be at Interrupt_Handler_Port0() */</span></div><div class="line">        (void)<a class="code" href="group__group__sysint__functions.html#ga7e5145f89effd2cd5950522748931b32">Cy_SysInt_SetVector</a>(intrCfg.<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>, &amp;Interrupt_Handler_Port0);</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gaa56f1672161e6725ae8c0a17f57a8277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa56f1672161e6725ae8c0a17f57a8277">&#9670;&nbsp;</a></span>Cy_SysInt_GetVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__syslib__macros.html#ga71c09beda7671d1f69c8f06a546e2ae6">cy_israddress</a> Cy_SysInt_GetVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i_r_qn___type.html">IRQn_Type</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the address of the current ISR vector for the Interrupt. </p>
<p>Note that for CM0+, this function returns the interrupt vector for the interrupt mux output feeding into the NVIC.</p>
<p>Note that this function relies on the assumption that the vector table is relocated to __ramVectors[RAM_VECTORS_SIZE] in SRAM.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intrSrc</td><td>Interrupt source</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Address of the ISR in the interrupt vector table</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Vector table is relocated to RAM in __ramVectors[]. The interrupt</span></div><div class="line"><span class="comment">                 was initialized with the &quot;intrCfg&quot; configuration struct. */</span></div><div class="line">    </div><div class="line">    <span class="comment">/* Prototype of ISR function for port interrupt 0 */</span></div><div class="line">    <span class="keywordtype">void</span> Interrupt_Handler_Port0 (<span class="keywordtype">void</span>);</div><div class="line">    </div><div class="line">    <span class="keywordflow">if</span>(&amp;Interrupt_Handler_Port0 != <a class="code" href="group__group__sysint__functions.html#gaa56f1672161e6725ae8c0a17f57a8277">Cy_SysInt_GetVector</a>(intrCfg.<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Set the port0 interrupt vector to be at Interrupt_Handler_Port0() */</span></div><div class="line">        (void)<a class="code" href="group__group__sysint__functions.html#ga7e5145f89effd2cd5950522748931b32">Cy_SysInt_SetVector</a>(intrCfg.<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>, &amp;Interrupt_Handler_Port0);</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gad11800befe8f66ff0c953e335cb172bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad11800befe8f66ff0c953e335cb172bb">&#9670;&nbsp;</a></span>Cy_SysInt_SetIntSourceNMI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SysInt_SetIntSourceNMI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i_r_qn___type.html">IRQn_Type</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the interrupt source of NMI. </p>
<p>The interrupt source must be a positive number. Setting the value to "unconnected_IRQn" (240) disconnects the interrupt source from the NMI.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intrSrc</td><td>Interrupt source</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Set the NMI trigger source for the processor of interest. The </span></div><div class="line"><span class="comment">                 interrupt was initialized with the &quot;intrCfg&quot; configuration struct. */</span></div><div class="line">    </div><div class="line">    <span class="keywordflow">if</span>(unconnected_IRQn == <a class="code" href="group__group__sysint__functions.html#ga34e083287947309c6c1e4ace72b911da">Cy_SysInt_GetIntSourceNMI</a>())</div><div class="line">    {</div><div class="line">        <span class="comment">/* Set the NMI source to GPIO port 0 interrupt */</span></div><div class="line"><span class="preprocessor">        #if (CY_CPU_CORTEX_M0P)</span></div><div class="line">            <a class="code" href="group__group__sysint__functions.html#gad11800befe8f66ff0c953e335cb172bb">Cy_SysInt_SetIntSourceNMI</a>((<a class="code" href="struct_i_r_qn___type.html">IRQn_Type</a>)ioss_interrupts_gpio_0_IRQn);</div><div class="line"><span class="preprocessor">        #else</span></div><div class="line">            <a class="code" href="group__group__sysint__functions.html#gad11800befe8f66ff0c953e335cb172bb">Cy_SysInt_SetIntSourceNMI</a>(ioss_interrupts_gpio_0_IRQn);</div><div class="line"><span class="preprocessor">        #endif</span></div><div class="line">    }</div><div class="line"></div></div><!-- fragment --> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The CM0+ NMI is used for performing system calls that execute out of ROM. Hence modification of the NMI source is strongly discouraged. However if it must be updated, the NMI source must be provided from the cy_en_intr_t enum as it is a direct connection to the interrupt source. </dd></dl>

</div>
</div>
<a id="ga34e083287947309c6c1e4ace72b911da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34e083287947309c6c1e4ace72b911da">&#9670;&nbsp;</a></span>Cy_SysInt_GetIntSourceNMI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="struct_i_r_qn___type.html">IRQn_Type</a> Cy_SysInt_GetIntSourceNMI </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the interrupt source of the NMI. </p>
<dl class="section return"><dt>Returns</dt><dd>Interrupt Source. A value of "unconnected_IRQn" (240) means that there is no interrupt source for the NMI, and it can be only be triggered through software.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Set the NMI trigger source for the processor of interest. The </span></div><div class="line"><span class="comment">                 interrupt was initialized with the &quot;intrCfg&quot; configuration struct. */</span></div><div class="line">    </div><div class="line">    <span class="keywordflow">if</span>(unconnected_IRQn == <a class="code" href="group__group__sysint__functions.html#ga34e083287947309c6c1e4ace72b911da">Cy_SysInt_GetIntSourceNMI</a>())</div><div class="line">    {</div><div class="line">        <span class="comment">/* Set the NMI source to GPIO port 0 interrupt */</span></div><div class="line"><span class="preprocessor">        #if (CY_CPU_CORTEX_M0P)</span></div><div class="line">            <a class="code" href="group__group__sysint__functions.html#gad11800befe8f66ff0c953e335cb172bb">Cy_SysInt_SetIntSourceNMI</a>((<a class="code" href="struct_i_r_qn___type.html">IRQn_Type</a>)ioss_interrupts_gpio_0_IRQn);</div><div class="line"><span class="preprocessor">        #else</span></div><div class="line">            <a class="code" href="group__group__sysint__functions.html#gad11800befe8f66ff0c953e335cb172bb">Cy_SysInt_SetIntSourceNMI</a>(ioss_interrupts_gpio_0_IRQn);</div><div class="line"><span class="preprocessor">        #endif</span></div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga86bb2a7b42f6706f5da5a55b7cb42022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86bb2a7b42f6706f5da5a55b7cb42022">&#9670;&nbsp;</a></span>Cy_SysInt_SetIntSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SysInt_SetIntSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i_r_qn___type.html">IRQn_Type</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a>&#160;</td>
          <td class="paramname"><em>cm0pSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the interrupt mux for the specified CM0+ NVIC channel. </p>
<p>Setting this value to "disconnected_IRQn" (240) disconnects the interrupt source and will effectively deactivate the interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intrSrc</td><td>NVIC mux number connected to the NVIC channel of the CM0+ core</td></tr>
    <tr><td class="paramname">cm0pSrc</td><td>Device interrupt to be routed to the NVIC mux</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Reconfigure the interrupt source of the NVIC input on the CM0+</span></div><div class="line"><span class="comment">                 core at run-time. The interrupt was initialized with the </span></div><div class="line"><span class="comment">                 &quot;intrCfg&quot; configuration struct. */</span></div><div class="line">    </div><div class="line">    <span class="keywordflow">if</span>(disconnected_IRQn == <a class="code" href="group__group__sysint__functions.html#ga82557e0d5a9cbd68677f58afbc19db55">Cy_SysInt_GetIntSource</a>(intrCfg.<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Set the interrupt source for intrCfg.intrSrc on CM0+ */</span></div><div class="line">        <a class="code" href="group__group__sysint__functions.html#ga86bb2a7b42f6706f5da5a55b7cb42022">Cy_SysInt_SetIntSource</a>(intrCfg.<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>, ioss_interrupts_gpio_0_IRQn);</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga82557e0d5a9cbd68677f58afbc19db55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82557e0d5a9cbd68677f58afbc19db55">&#9670;&nbsp;</a></span>Cy_SysInt_GetIntSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a> Cy_SysInt_GetIntSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i_r_qn___type.html">IRQn_Type</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the interrupt source of CM0+ NVIC channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intrSrc</td><td>NVIC mux number connected to the NVIC channel of the CM0+ core</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Device interrupt source connected to the NVIC mux. A returned value of "disconnected_IRQn" (240) indicates that the interrupt source is disconnected.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Reconfigure the interrupt source of the NVIC input on the CM0+</span></div><div class="line"><span class="comment">                 core at run-time. The interrupt was initialized with the </span></div><div class="line"><span class="comment">                 &quot;intrCfg&quot; configuration struct. */</span></div><div class="line">    </div><div class="line">    <span class="keywordflow">if</span>(disconnected_IRQn == <a class="code" href="group__group__sysint__functions.html#ga82557e0d5a9cbd68677f58afbc19db55">Cy_SysInt_GetIntSource</a>(intrCfg.<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Set the interrupt source for intrCfg.intrSrc on CM0+ */</span></div><div class="line">        <a class="code" href="group__group__sysint__functions.html#ga86bb2a7b42f6706f5da5a55b7cb42022">Cy_SysInt_SetIntSource</a>(intrCfg.<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>, ioss_interrupts_gpio_0_IRQn);</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gab6b70fb2e54d2bf2453ce20acd0a11b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6b70fb2e54d2bf2453ce20acd0a11b9">&#9670;&nbsp;</a></span>Cy_SysInt_SoftwareTrig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SysInt_SoftwareTrig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i_r_qn___type.html">IRQn_Type</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Triggers an interrupt using software (Not applicable for CM0+). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intrSrc</td><td>Interrupt source</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Trigger the CM4 interrupt line connected to the GPIO port 0</span></div><div class="line"><span class="comment">                 interrupt from software. */</span></div><div class="line">    </div><div class="line">    <span class="comment">/* Enter processor privileged mode */</span></div><div class="line">    __set_CONTROL(0);</div><div class="line">    </div><div class="line">    <span class="comment">/* Trigger the ioss_interrupts_gpio_0_IRQn interrupt using software */</span></div><div class="line">    <a class="code" href="group__group__sysint__functions.html#gab6b70fb2e54d2bf2453ce20acd0a11b9">Cy_SysInt_SoftwareTrig</a>(ioss_interrupts_gpio_0_IRQn);</div><div class="line"></div><div class="line">    <span class="comment">/* Enter processor user mode */</span> </div><div class="line">    __set_CONTROL(1);</div><div class="line">    </div></div><!-- fragment --> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only privileged software can enable unprivileged access to the Software Trigger Interrupt Register (STIR). </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>Cypress Peripheral Driver Library (PDL)</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
