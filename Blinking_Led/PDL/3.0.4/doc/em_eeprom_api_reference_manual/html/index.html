<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cypress Em_EEPROM Middleware Library: Cypress Em_EEPROM Middleware Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="cypress_logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Cypress Em_EEPROM Middleware Library
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Cypress Em_EEPROM Middleware Library </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The Emulated EEPROM provides an API that allows creating an emulated EEPROM in flash that has the ability to do wear leveling and restore corrupted data from a redundant copy. The Emulated EEPROM library is designed to be used with the Em_EEPROM component.</p>
<p>The Cy_Em_EEPROM API is described in the following sections:</p><ul>
<li><a class="el" href="group__group__em__eeprom__macros.html">Macros</a></li>
<li><a class="el" href="group__group__em__eeprom__data__structures.html">Data Structures</a></li>
<li><a class="el" href="group__group__em__eeprom__enums.html">Enumerated types</a></li>
<li><a class="el" href="group__group__em__eeprom__functions.html">Functions</a></li>
</ul>
<p><b>Features:</b></p><ul>
<li>EEPROM-Like Non-Volatile Storage</li>
<li>Easy to use Read and Write API</li>
<li>Optional Wear Leveling</li>
<li>Optional Redundant Data storage</li>
</ul>
<h1><a class="anchor" id="group_em_eeprom_configuration"></a>
Configuration Considerations</h1>
<p>The Em_EEPROM operates on the top of the flash driver. The flash driver has some prerequisites for proper operation. Refer to the "Flash System 
Routine (Flash)" section of the PDL API Reference Manual.</p>
<p><b>Initializing Emulated EEPROM in User flash</b></p>
<p>To initialize an Emulated EEPROM in the User flash, the EEPROM storage should be declared by the user. For the proper operation, the EEPROM storage should be aligned to the size of the flash row. An example of the EEPROM storage declaration is below (applicable for GCC and MDK compilers): </p><pre class="fragment"> CY_ALIGN(CY_EM_EEPROM_FLASH_SIZEOF_ROW)
 const uint8_t emEeprom[Em_EEPROM_PHYSICAL_SIZE] = {0u};
</pre><p>The same declaration for the IAR compiler: </p><pre class="fragment"> #pragma data_alignment = CY_EM_EEPROM_FLASH_SIZEOF_ROW
 const uint8_t emEeprom[Em_EEPROM_PHYSICAL_SIZE] = {0u};
</pre><p>Note that the name "emEeprom" is shown for reference. Any other name can be used instead. Also, note that the Em_EEPROM_PHYSICAL_SIZE constant is generated by the PSoC Creator Em_EEPROM component and so it is instance name dependent and its prefix should be changed when the name of the component changes. If the The Cy_Em_EEPROM middleware library is used without the Em_EEPROM component, the user has to provide a proper size for the EEPROM storage instead of Em_EEPROM_PHYSICAL_SIZE. The size of the EEPROM storage can be calculated using the following equation:</p>
<p>Physical size = EEPROM data size * 2 * wear leveling * (1 + redundant copy)</p>
<p>where, "EEPROM data size" - the size of data the user wants to store in the EEPROM. The data size must divide evenly to the half of the flash row size. "wear leveling" - the wear leveling factor (1-10). "redundant copy" - "zero" if a redundant copy is not used, and "one" otherwise.</p>
<p>The start address of the storage should be filled to the Emulated EEPROM configuration structure and then passed to the <a class="el" href="group__group__em__eeprom__functions.html#ga49df98ebc721d60425f383ef90a1e8e0" title="Initializes the Emulated EEPROM library by filling the context structure. ">Cy_Em_EEPROM_Init()</a>. If the Em_EEPROM component is used, the config (Em_EEPROM_config) and context structures (Em_EEPROM_context) are defined by the component, so the user may just use that structures otherwise both of the structures need to be provided by the user. Note that if the "Config Data in Flash" option is selected in the component, then the configuration structure should be copied to RAM to allow EEPROM storage start address update. The following code demonstrates utilization of "Em_EEPROM_config" and "Em_EEPROM_context" Em_EEPROM component structures for Cy_Em_EEPROM middleware library initialization: </p><pre class="fragment"> cy_en_em_eeprom_status_t retValue;
 cy_stc_eeprom_config_t config;

 memcpy((void *)&amp;config, 
        (void *)&amp;Em_EEPROM_config, 
        sizeof(cy_stc_eeprom_config_t));
 config.userFlashStartAddr = (uint32_t)emEeprom;
 retValue = Cy_Em_EEPROM_Init(&amp;config, &amp;Em_EEPROM_context);
</pre><p><b>Initializing EEPROM in Emulated EEPROM flash area</b></p>
<p>Initializing of the EEPROM storage in the Emulated EEPROM flash area is identical to initializing of the EEPROM storage in the User flash with one difference. The location of the Emulated EEPROM storage should be specified somewhere in the EmulatedEEPROM flash area. If the Em_EEPROM component is utilized in the project, then the respective storage (Em_EEPROM_em_EepromStorage[]) is automatically declared by the component if the "Use Emulated EEPROM" option is set to "Yes". The user just needs to fill the start address of the storage to the config structure. If the Em_EEPROM component is not used, the user needs to declare the storage in the Emulated EEPROM flash area. An example of such declaration is following (applicable for GCC and MDK compilers): </p><pre class="fragment"> CY_SECTION(".cy_em_eeprom") CY_ALIGN(CY_EM_EEPROM_FLASH_SIZEOF_ROW)
 const uint8_t emEeprom[Em_EEPROM_PHYSICAL_SIZE] = {0u};
</pre><p>The same declaration for the IAR compiler: </p><pre class="fragment"> #pragma location = ".cy_em_eeprom"
 #pragma data_alignment = CY_EM_EEPROM_FLASH_SIZEOF_ROW
 const uint8_t emEeprom[Em_EEPROM_PHYSICAL_SIZE] = {0u};
</pre><p>where, Em_EEPROM_PHYSICAL_SIZE - is a constant that is generated by the Em_EEPROM component when the component is utilized in the project or it should be provided by the user. The equation for the calculation of the constant is shown above.</p>
<p>Note that the size of the Emulated EEPROM flash area is limited. Refer to the specific device datasheet for the value of the available EEPROM Emulation area.</p>
<p>Also note that by default, the Em_EEPROM storage is fully allocated to both of the PSoC 6 cores in the ".cy_em_eeprom" section. If the Em_EEPROM is used on one of the cores, you must reallocate the declaration of the ".cy_em_eeprom" section in both linker scripts. Otherwise, while building the project the cymcuelftool will report an error because of ".cy_em_eeprom" section contents collision.</p>
<h1><a class="anchor" id="group_em_eeprom_more_information"></a>
More Information</h1>
<p>See the Em_EEPROM Component datasheet.</p>
<h1><a class="anchor" id="group_em_eeprom_MISRA"></a>
MISRA-C Compliance</h1>
<p>The Cy_Em_EEPROM library has the following specific deviations:</p>
<table class="doxtable">
<tr>
<th>MISRA Rule </th><th>Rule Class (Required/Advisory) </th><th>Rule Description </th><th>Description of Deviation(s)  </th></tr>
<tr>
<td>11.4 </td><td>A </td><td>The cast should not be performed between a pointer to the object type and a different pointer to the object type. </td><td>The cast from the object type and a different pointer to the object was used intentionally because of the performance reasons.  </td></tr>
<tr>
<td>14.2 </td><td>R </td><td>All non-null statements shall either have at least one side-effect, however executed, or cause control flow to change. </td><td>To maintain common codebase, some variables, unused for a specific device, are casted to void to prevent generation of an unused variable compiler warning.  </td></tr>
<tr>
<td>16.7 </td><td>A </td><td>The object addressed by the pointer parameter is not modified and so the pointer could be of type 'pointer to const'. </td><td>The warning is generated because of the pointer dereferencing to address which makes the MISRA checker think the data is not modified.  </td></tr>
<tr>
<td>17.4 </td><td>R </td><td>The array indexing shall be the only allowed form of pointer arithmetic. </td><td>The pointer arithmetic used in several places on the Cy_Em_EEPROM implementation is safe and preferred because it increases the code flexibility.  </td></tr>
<tr>
<td>19.7 </td><td>A </td><td>A function shall be used in preference to a function-like macro. </td><td>Macro is used because of performance reasons.  </td></tr>
</table>
<h1><a class="anchor" id="group_em_eeprom_changelog"></a>
Changelog</h1>
<table class="doxtable">
<tr>
<th>Version</th><th>Changes</th><th>Reason for Change </th></tr>
<tr>
<td>1.0.1 </td><td>EM_EEPROM storage allocation note added to <a class="el" href="index.html#group_em_eeprom_configuration">Configuration Considerations</a> </td><td>Documentation update and clarification  </td></tr>
<tr>
<td>1.0 </td><td>Initial Version </td><td></td></tr>
</table>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>Cypress Em_EEPROM Middleware Library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
